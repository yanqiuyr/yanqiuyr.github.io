<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数字三角形（JAVA）</title>
    <link href="/2023/05/02/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/02/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/img/tupian01.png" alt="说明图片"><br>上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。</p><p>路径上的每一步只能从一个数走到下一层和它最近的左边的那个数或者右 边的那个数。此外，向左下走的次数与向右下走的次数相差不能超过 1。</p><p><strong>输入描述</strong></p><p>输入的第一行包含一个整数 N (1≤N≤100)，表示三角形的行数。</p><p>下面的 N 行给出数字三角形。数字三角形上的数都是 0 至 100 之间的整数。</p><p><strong>输出描述</strong></p><p>输出一个整数，表示答案。</p><p><strong>输入输出样例</strong></p><p>示例</p><blockquote><p>输入</p></blockquote><p><code>5 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5</code></p><blockquote><p>输出</p></blockquote><p><code>27</code></p><p><strong>运行限制</strong></p><p>-最大运行时间：1S</p><p>-最大运行内存：256M</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> N=scan.nextInt();<br>        <span class="hljs-type">int</span>[][] arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [N][N];   <span class="hljs-comment">//二维数组arr储存数字三角形</span><br>        <span class="hljs-type">int</span>[][] pre=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][N];   <span class="hljs-comment">//二维数组pre储存路径，初始为零向左走减1向右走加1</span><br>        <span class="hljs-type">int</span>[][] dp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][N];    <span class="hljs-comment">//二维数组dp储存走到对应位置的最大和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;a&lt;=i;a++)&#123;<br>                arr[i][a]=scan.nextInt();<br>                pre[i][a]=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<span class="hljs-comment">//三角形顶点最大和就是它本身</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>]=dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+arr[i][<span class="hljs-number">0</span>];<br>            pre[i][<span class="hljs-number">0</span>]=pre[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-<span class="hljs-number">1</span>;<br>        &#125;                            <span class="hljs-comment">//只有通过arr[i-1][0]才能到达arr[i][0]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N;i++)&#123;<br>            dp[i][i]=dp[i-<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>]+arr[i][i];<br>            pre[i][i]=pre[i-<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>        &#125;                             <span class="hljs-comment">//只有通过arr[i-1][i-1]才能到达arr[i][i]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span> (dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]&gt;dp[i-<span class="hljs-number">1</span>][j])&#123;<br>                    pre[i][j]=pre[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>                    dp[i][j]=arr[i][j]+dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125;                     <br>                <span class="hljs-keyword">else</span>&#123;<br>                    pre[i][j]=pre[i-<span class="hljs-number">1</span>][j]-<span class="hljs-number">1</span>;<br>                    dp[i][j]=arr[i][j]+dp[i-<span class="hljs-number">1</span>][j];<br>                &#125;       <br> <br>            &#125;<br>        &#125;               <span class="hljs-comment">//arr[i][j]可以从arr[i-1][j-1]或arr[i-1][j]到达所以要比较找出最大值</span><br>        <span class="hljs-type">int</span>[] sum=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [N];   <span class="hljs-comment">//定义sum数组储存到达最底部符合条件的和初始为零</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>            sum[i]=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (pre[N-<span class="hljs-number">1</span>][i]&lt;=<span class="hljs-number">1</span>&amp;&amp;pre[N-<span class="hljs-number">1</span>][i]&gt;=-<span class="hljs-number">1</span>)&#123;<br>                sum[i]=dp[N-<span class="hljs-number">1</span>][i];<br>            &#125;                  <span class="hljs-comment">//pre二维数组记录路径只要为-1，0，1三个数就说明向左下和右下走的次数不超过1，记录数据最终进行比较</span><br> <br>        &#125;<br>        <span class="hljs-type">int</span> max=sum[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>            <span class="hljs-keyword">if</span>(max&lt;sum[i])&#123;<br>                max=sum[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                max=max;<br>            &#125;<br>        &#125;                  <br>        System.out.println(max);     <span class="hljs-comment">//通过比较选出最大路径并输出</span><br>        scan.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>将数字三角形转化到为二维数组中进行存储，由于最左侧一列和对角线都有固定的路径，再加以分析得到中间数字的路径从而获得三个状态转移方程（除去顶点）：</p><p>dp[i][0]&#x3D;dp[i-1][0]+arr[i][0];</p><p>dp[i][i]&#x3D;dp[i-1][i-1]+arr[i][i];</p><p>dp[i][j]&#x3D;max(dp[i-1][j-1],dp[i-1][j])+arr[i][j];</p><p>题目还对左下和右下走的次数有限制，因此我们用pre二维数组记录路径左下走-1右下走+1最终进行判断比较得出最大值并输出。</p><p><strong>CSDN</strong> <a href="https://blog.csdn.net/qq_63746090/article/details/129246539?spm=1001.2014.3001.5501">原文链接</a></p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/04/26/hello-world/"/>
    <url>/2023/04/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
