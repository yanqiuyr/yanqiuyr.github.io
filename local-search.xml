<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>求阶乘（JAVA）</title>
    <link href="/2023/05/07/%E6%B1%82%E9%98%B6%E4%B9%98%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/07/%E6%B1%82%E9%98%B6%E4%B9%98%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>满足 N ! 的末尾恰好有 K 个 0 的最小的 N 是多少?</p><p>如果这样的 N 不存在输出 −1 。</p><p><strong>输入格式</strong><br>一个整数 K 。</p><p><strong>输出格式</strong><br>一个整数代表答案。</p><p><strong>样例输入</strong></p><blockquote><p>2</p></blockquote><p><strong>样例输出</strong></p><blockquote><p>10</p></blockquote><p><strong>评测用例规模与约定</strong><br>对于 30% 的数据, 1≤K≤106.</p><p>对于 100% 的数据, 1≤K≤1018.</p><p><strong>运行限制</strong><br>最大运行时间：3s<br>最大运行内存: 512M</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-comment">// 1:无需package</span><br><span class="hljs-comment">// 2: 类名必须Main, 不可修改</span><br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">long</span> K=sc.nextLong();               <span class="hljs-comment">//输入K</span><br>        <span class="hljs-type">long</span> left=<span class="hljs-number">1</span>;                        <span class="hljs-comment">//左边界</span><br>        <span class="hljs-type">long</span> right=Long.MAX_VALUE-<span class="hljs-number">1</span>;         <span class="hljs-comment">//右边界</span><br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;                   <span class="hljs-comment">//二分法查找，因为要找最小值所以要令其不符合条件时自动退出循环，不能使用break语句停止。left（左边界）right（右边界）</span><br>            <span class="hljs-type">long</span> mid=(left+right)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (f(mid)&lt;K)&#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (f(mid)&gt;=K)&#123;<br>                right=mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (f(right)==K)&#123;               <span class="hljs-comment">//符合条件输出值，不符合条件输出-1</span><br>            System.out.println(right);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;-1&quot;</span>);<br>        &#125;<br>        sc.close();<br> <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">long</span> a)</span>&#123;    <span class="hljs-comment">//看有几个五来确定末尾有几个零</span><br>        <span class="hljs-type">long</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(a&gt;<span class="hljs-number">0</span>)&#123;<br>            sum+=a/<span class="hljs-number">5</span>;<br>            a=a/<span class="hljs-number">5</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>看到题目我觉得这道题应该是找规律的（K的取值那么大总不可能是暴力输出吧（doge）），然后发现5的时候末尾有一个0，10的时候末尾有两个0，15的时候末尾有三个0。</p><p>那么这题的规律就来了。</p><p>一个数的阶乘末尾如果想有0，那么就要乘10，而2<em>5&#x3D;10（剩下的7个数相乘凑不出来10），所以我们就需要找有几个2</em>5，因为2比5小所以在一个数的阶乘中，包含2的个数一定比5的个数多，所以转换成我们需要求5的个数。下面举几个例子帮助大家理解</p><p>5！&#x3D;1<em>2</em>3<em>4</em>5   其中有5&#x2F;5&#x3D;1个5。</p><p>10！&#x3D;1<em>2</em>3*……<em>9</em>10     其中有10&#x2F;5&#x3D;2个5。</p><p>13！&#x3D;1<em>2</em>3*…..<em>12</em>13     其中有13&#x2F;5&#x3D;2个5。</p><p>25！&#x3D;1<em>2</em>3*….<em>24</em>25   其中有25&#x2F;5&#x3D;5个5（等等好像不对）25！中应该有6个5吧我们来数一下，5&#x3D;1<em>5，10&#x3D;2</em>5，15&#x3D;3<em>5，20&#x3D;4</em>5，25&#x3D;5*5。25可以分解为两个5，相应的125可以分解成3个5相乘，所以我们要用循环将其除尽才能得出正确的5的个数。</p><p>好规律找到了（阶乘末尾有几个0取决于该数可以分解出几个5），我们就需要进行查找了，这里我们选择使用二分法（因为快）。</p><p>使用二分法就需要找左右边界，左边界很好找就是1，右边界呢？</p><p>因为</p><p>Long.MAX_VALUE的阶乘后边有   2305843009213693937个0(10的19次方) &gt; k<br>Long.MAX_VALUE&#x2F;2的阶乘后边有 1152921504606846964个0(10的19次方) &gt; k<br>（其它博主的文章里复制的）<br>这里给上原文链接：<a href="http://t.csdn.cn/rDIsy">http://t.csdn.cn/rDIsy</a></p><p>所以右边界我们就用Long.MAX_VALUE为了防止在二分时相加越界，所以右边界用Long.MAX_VALUE-1（减几都可以（也不能减太多（doge）））。</p><p>至此我们通过找规律和二分查找成功解决问题。</p><p>注：其实一开始我也只是意识到有规律并没有准确找到，这道题是看过题解后才写出来的，还是差太多了，一起加油吧各位。</p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最少刷题数（JAVA）</title>
    <link href="/2023/05/07/%E6%9C%80%E5%B0%91%E5%88%B7%E9%A2%98%E6%95%B0%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/07/%E6%9C%80%E5%B0%91%E5%88%B7%E9%A2%98%E6%95%B0%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>小蓝老师教的编程课有 N 名学生, 编号依次是 1…N 。第 i 号学生这学期 刷题的数量是Ai 。</p><p>对于每一名学生, 请你计算他至少还要再刷多少道题, 才能使得全班刷题 比他多的学生数不超过刷题比他少的学生数。</p><p><strong>输入格式</strong><br>第一行包含一个正整数 N 。</p><p>第二行包含 N 个整数:A1,A2,A3,…,AN.</p><p><strong>输出格式</strong><br>输出 N 个整数, 依次表示第1…N 号学生分别至少还要再刷多少道题。</p><p><strong>样例输入</strong></p><blockquote><p>5<br>12 10 15 20 6</p></blockquote><p><strong>样例输出</strong></p><blockquote><p>0 3 0 0 7</p></blockquote><p><strong>评测用例规模与约定</strong><br>对于 30% 的数据, 1≤N≤1000,0≤Ai≤1000.</p><p>对于 100% 的数据, 1≤N≤100000,0≤Ai≤100000.</p><p><strong>运行限制</strong><br>最大运行时间：1s<br>最大运行内存: 512M</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">zui_shao_shua_ti_shu</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> n,mid;                   <span class="hljs-comment">//n个学生，mid是中间值</span><br>        n=sc.nextInt();<br>        <span class="hljs-type">int</span> [] arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];       <span class="hljs-comment">//存放每个学生做题数。</span><br>        <span class="hljs-type">int</span> [] a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];         <span class="hljs-comment">//将arr数组复制一份进行排序</span><br>        <span class="hljs-type">int</span> [] result=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];     <span class="hljs-comment">//存储结果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            arr[i]=sc.nextInt();<br>            a[i]=arr[i];            <span class="hljs-comment">//输入并复制。</span><br>        &#125;<br>     kuaipai(a,<span class="hljs-number">0</span>,a.length-<span class="hljs-number">1</span>);      <span class="hljs-comment">//用快排进行排序，必须用快排否则会超时几毫秒。</span><br>        mid=a[n/<span class="hljs-number">2</span>];   <br>        <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>;                   <span class="hljs-comment">//判断当刷题数比中间值小时结果是否需要加一（默认不加）</span><br>        <span class="hljs-type">int</span> c=<span class="hljs-number">0</span>;                   <span class="hljs-comment">//判断结果等于中间值时是否需要加一（默认不加）</span><br>        <span class="hljs-type">int</span> bigger=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> smaller=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i]&gt;mid)&#123;<br>                bigger++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (arr[i]&lt;mid)&#123;<br>                smaller++;          <span class="hljs-comment">//计算比中间值大的和小的个数</span><br>            &#125;<br> <br>        &#125;<br>        <span class="hljs-keyword">if</span> (bigger&gt;=smaller)&#123;<br>            b=<span class="hljs-number">1</span>;                <br>        &#125;<br>        <span class="hljs-keyword">if</span> (bigger&gt;smaller)&#123;<br>            c=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span> (arr[i]&lt;mid)&#123;<br>                result[i]=mid+b-arr[i];<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (arr[i] == mid) &#123;<br>                    result[i] = c;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    result[i]=<span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>            System.out.print(result[i]+<span class="hljs-string">&quot; &quot;</span>);     <span class="hljs-comment">//判断并输出</span><br>        &#125;<br> <br> <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">kuaipai</span><span class="hljs-params">(<span class="hljs-type">int</span> [] a,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span>&#123;   <span class="hljs-comment">//快排</span><br>        <span class="hljs-keyword">if</span> (l&gt;=r)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> low=l;<br>        <span class="hljs-type">int</span> high=r;<br>        <span class="hljs-type">int</span> pivot=a[l];<br>        <span class="hljs-keyword">while</span>(low&lt;high)&#123;<br>            <span class="hljs-keyword">while</span>(a[high]&gt;=pivot&amp;&amp;low&lt;high)&#123;<br>                high--;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(a[low]&lt;=pivot&amp;&amp;low&lt;high)&#123;<br>                low++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (low&lt;high)&#123;<br>                <span class="hljs-type">int</span> temp=a[high];<br>                a[high]=a[low];<br>                a[low]=temp;<br>            &#125;<br> <br>        &#125;<br>        a[l]=a[low];<br>        a[low]=pivot;<br>        kuaipai(a,l,low-<span class="hljs-number">1</span>);<br>        kuaipai(a,low+<span class="hljs-number">1</span>,r);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>首先想到的是依靠中间值进行解题，第一次写的代码忽略了中间值可能重复，只通过了3个用例，然后开始改进，这里举几个例子：</p><p>3 4 5 6 6 6 7 8 9</p><p>如果学生刷题数是这个数组，中间值为6。</p><p>其中比6大的有3个比6小的也有3个如果第一个做三道题的学生做到中间值6那么比6小的有2个比6大的有3个不符合要求。刷题数正好是6的同学一道题也不用刷。</p><p>3 4 6 6 7 8 9</p><p>这个例子比6小的有2个比6大的有3个，所以刷6个题的同学依然要再刷一题才符合要求。</p><p>题目中要求比他多的学生数不超过刷题比他少的学生数，那么我们将数组排序中间值肯定是一个分水岭，接下来就需要考虑特殊情况找规律了。</p><p>然后呢这道题一开始我用的是Arrays.sort进行排序但发现有三个用例过不去，又尝试了几次发现过不去的三个用例中有几次过去了用时是九百多毫秒，然后就觉得可能程序只是满了几毫秒而导致超时，只要找到一个优化的点应该就能过去了。然后我将排序改成了快排刚好通过<br>快排虽然写着麻烦些但对计算机来说速度快很多，遇到这种情况的时候很管用，所以快排可以不用但一定要会写。</p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>山（JAVA）</title>
    <link href="/2023/05/07/%E5%B1%B1%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/07/%E5%B1%B1%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p><strong>本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。</strong></p><p>这天小明正在学数数。</p><p>他突然发现有些止整数的形状像一挫 “山”, 比如 123565321 ，145541, 它 们左右对称 (回文) 且数位上的数字先单调不减, 后单调不增。</p><p>小朋数了衣久也没有数完, 他惒让你告诉他在区间[2022,2022222022] 中有 多少个数的形状像一座 “山”。<br><strong>运行限制</strong></p><ul><li>最大运行时间：1s</li><li>最大运行内存: 512M</li></ul><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">shan</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">2022</span>;i&lt;=<span class="hljs-number">2022222022</span>;i++)&#123;<br>            String s=i+<span class="hljs-string">&quot;&quot;</span>;                 <span class="hljs-comment">//将数字转化为字符串也可以用Integer.toString(i)</span><br>            <span class="hljs-keyword">if</span> (huiwen(s)&amp;&amp;dizeng(s)) &#123;<br>                sum++;                     <span class="hljs-comment">//存储符合要求的回文数字的数目</span><br>            &#125;<br>        &#125;<br>        System.out.println(sum);<br> <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">huiwen</span><span class="hljs-params">(String s)</span>&#123;            <span class="hljs-comment">//判断是否是回文</span><br>       StringBuilder stringBuilder=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(s);<br>       stringBuilder.reverse();                          <span class="hljs-comment">//将字符串进行反转</span><br>       <span class="hljs-keyword">return</span> s.equals(stringBuilder.toString());    <span class="hljs-comment">//反转后是以字符数组的形式进行存储的，所以要转成字符串。</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dizeng</span><span class="hljs-params">(String s)</span>&#123;    <span class="hljs-comment">//判断是否符合先单调不减, 后单调不增。由于是回文数所以判断一半即可。</span><br>        <span class="hljs-type">int</span> a=s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a-a/<span class="hljs-number">2</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span> (i&gt;<span class="hljs-number">0</span>&amp;&amp;s.charAt(i-<span class="hljs-number">1</span>)&gt;s.charAt(i))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>暴力解法遍历每一个数，先判断是否是回文数再判断是否符合先单调不减, 后单调不增。</p><p>判断回文的时候用到了StringBuilder中的reverse方法将字符串进行反转。</p><p>由于是暴力解法所以代码运行时间较长（我运行了一分半时间左右），但本题是填空题，作答时直接输出答案即可。</p><p>答案是：3138</p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双向排序（JAVA）</title>
    <link href="/2023/05/07/%E5%8F%8C%E5%90%91%E6%8E%92%E5%BA%8F%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/07/%E5%8F%8C%E5%90%91%E6%8E%92%E5%BA%8F%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给定序列(a1,a2,⋅⋅⋅,an)&#x3D;(1,2,⋅⋅⋅,n)，即 ai&#x3D;i。</p><p>小蓝将对这个序列进行 m 次操作，每次可能是将 a1,a2,⋯,aqi 降序排列，或者将aqi,aqi+1,⋯,an 升序排列。</p><p>请求出操作完成后的序列。</p><p><strong>输入描述</strong><br>输入的第一行包含两个整数 n,m，分别表示序列的长度和操作次数。</p><p>接下来 m 行描述对序列的操作，其中第 i 行包含两个整数pi,qi 表示操作类型和参数。当pi&#x3D;0 时，表示将 a1,a2,⋅⋅⋅,aqi 降序排列；当pi&#x3D;1 时，表示将 aqi,aqi+1,⋯,an 升序排列。</p><p><strong>输出描述</strong><br>输出一行，包含 nn 个整数，相邻的整数之间使用一个空格分隔，表示操作完成后的序列。</p><p><strong>输入输出样例</strong><br>示例</p><p><strong>输入</strong></p><blockquote><p>3 3<br>0 3<br>1 2<br>0 2</p></blockquote><p><strong>输出</strong></p><blockquote><p>3 1 2</p></blockquote><p><strong>样例说明</strong><br>原数列为 (1, 2, 3)(1,2,3)。</p><p>第 11 步后为 (3, 2, 1)(3,2,1)。</p><p>第 22 步后为 (3, 1, 2)(3,1,2)。</p><p>第 33 步后为 (3, 1, 2)(3,1,2)。与第 22 步操作后相同，因为前两个数已经是降序了。</p><p><strong>评测用例规模与约定</strong><br>对于 30%30% 的评测用例，n, m \leq 1000n,m≤1000；</p><p>对于 60%60% 的评测用例，n, m \leq 5000n,m≤5000；</p><p>对于所有评测用例，1 \leq n, m \leq 100000，0 \leq p_i \leq 1，1 \leq q_i \leq n1≤n,m≤100000，0≤pi≤1，1≤qi≤n。</p><p><strong>运行限制</strong><br><strong>语言</strong><strong>最大运行时间</strong><strong>最大运行内存</strong><br>C++       1s                256M<br>C            1s                256M<br>Java       1s                 256M<br>Python31s                256M</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p> 首先我想到的是根据条件进行暴力排序但只能通过40%的用例，然后就查看题解进行优化。</p><p>优化的思路就是将排序的次数进行压缩。以1 2 3 4 5 6 7 8 9为例</p><p>1.因为给定的数组一开始就是按照升序排列所以第一次排序一定是降序排列所以在找到第一次降序排列时所有的升序排列都不进行记数。</p><p>2.连续的降序排列我们只需要取范围最大的那一个如</p><p>4 3 2 1 5 6 7 8 9    1到4降序</p><p>6 5 4 3 2 1 7 8 9    1到6 降序</p><p>6 5 4 3 2 1 7 8 9    1到3降序</p><p>其中我们只用进行一次1到6降序即可其它两个降序排列可以省去。</p><p>3.连续的升序排列也是同理。最后会得到一个升序降序交替进行的结果。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br>    <span class="hljs-keyword">static</span> pair[] stk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">pair</span>[N];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//初始化栈顶</span><br>        <span class="hljs-type">int</span> p, q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            p = scanner.nextInt();<br>            q = scanner.nextInt();<br>            <span class="hljs-keyword">if</span> (p == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">//求出连续操作的最长前缀</span><br>                <span class="hljs-keyword">while</span> (top != <span class="hljs-number">0</span> &amp;&amp; stk[top].x == <span class="hljs-number">0</span>)<br>                    q = Math.max(q, stk[top--].y);<br>                <span class="hljs-comment">//删去所有比它小的前缀操作</span><br>                <span class="hljs-keyword">while</span> (top &gt;= <span class="hljs-number">2</span> &amp;&amp; stk[top - <span class="hljs-number">1</span>].y &lt;= q)<br>                    top -= <span class="hljs-number">2</span>;<br>                <span class="hljs-comment">//加上当前的前缀操作</span><br>                stk[++top] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">pair</span>(<span class="hljs-number">0</span>, q);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (top != <span class="hljs-number">0</span>) &#123;<br>            <br>                <span class="hljs-keyword">while</span> (top != <span class="hljs-number">0</span> &amp;&amp; stk[top].x == <span class="hljs-number">1</span>)<br>                    q = Math.min(q, stk[top--].y);<br>                <br>                <span class="hljs-keyword">while</span> (top &gt;= <span class="hljs-number">2</span> &amp;&amp; stk[top - <span class="hljs-number">1</span>].y &gt;= q)<br>                    top -= <span class="hljs-number">2</span>;<br>               <br>                stk[++top] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">pair</span>(<span class="hljs-number">1</span>, q);<br>            &#125;<br>        &#125;                                        <span class="hljs-comment">//这一部分是进行压缩，下面是进行排序。</span><br>      <br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> n, l = <span class="hljs-number">1</span>, r = n;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= top; i++) &#123;<br>            <span class="hljs-keyword">if</span> (stk[i].x == <span class="hljs-number">0</span>) &#123;<br>              <br>                <span class="hljs-keyword">while</span> (r &gt; stk[i].y &amp;&amp; l &lt;= r) ans[r--] = k--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <br>                <span class="hljs-keyword">while</span> (l &lt; stk[i].y &amp;&amp; l &lt;= r) ans[l++] = k--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (top % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">while</span> (l &lt;= r) ans[l++] = k--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (l &lt;= r) ans[r--] = k--;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            System.out.printf(<span class="hljs-string">&quot;%d &quot;</span>, ans[i]);<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">pair</span> &#123;<br>        <span class="hljs-type">int</span> x, y;<br> <br>        pair(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<br>            <span class="hljs-built_in">this</span>.x = x;<br>            <span class="hljs-built_in">this</span>.y = y;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杨辉三角形（JAVA）</title>
    <link href="/2023/05/07/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/07/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>下面的图形是著名的<a href="https://so.csdn.net/so/search?q=%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E5%BD%A2&spm=1001.2101.3001.7020">杨辉三角形</a>：</p><p><img src="/img/tupian04.png"></p><p>如果我们按从上到下、从左到右的顺序把所有数排成一列，可以得到如下数列：1,1,1,1,2,1,1,3,3,1,1,4,6,4,1,⋯</p><p>给定一个正整数 N，请你输出数列中第一次出现 N 是在第几个数？</p><p><strong>输入描述</strong><br>输入一个整数 N。</p><p><strong>输出描述</strong><br>输出一个整数代表答案。</p><p><strong>输入输出样例</strong><br>示例 1</p><p><strong>输入</strong></p><blockquote><p>6</p></blockquote><p><strong>输出</strong></p><blockquote><p>13</p></blockquote><p><strong>评测用例规模与约定</strong><br>对于 20% 的评测用例，1≤N≤10； 对于所有评测用例，1≤N≤1000000000。</p><p><strong>运行限制</strong><br>最大运行时间：1s<br>最大运行内存: 256M</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>首先我想到的是将杨辉三角形构建出来再进行查找，但N的最大值是1*10^9，经过亲身实践只能通过40%的用例</p><p><img src="/img/tupian07.png"></p><p> 所以需要找规律</p><p>杨辉三角形：</p><p><img src="/img/tupian05.png"></p><p> 需要考虑的部分：</p><p><img src="/img/tupian06.png"></p><p>其中6&#x3D;c(2,4) 2&#x3D;c(1,2)因为10^9&gt;c(16,32)但10^9&lt;c(17,34),所以在16列以内肯定能找到所有的数，有效数列是0-16列。又因为每一行都是从左到右递增，每一列都是从上到下递增，每个数字都可以表示为c(i,j)。所以我们可以从十六列开始，逐步往前找采用二分行的方式找到答案。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-comment">// 1:无需package</span><br><span class="hljs-comment">// 2: 类名必须Main, 不可修改</span><br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">long</span> N=sc.nextLong();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">16</span>;k&gt;=<span class="hljs-number">0</span>;k--)&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * k, r = Math.max(N, l), mid=<span class="hljs-number">0</span>;  <span class="hljs-comment">//代码是根据其它博主的博客写的这里我的理解是从2*k行开始才有的第16列有效数据然后加上r（r的理解有些模糊）再用二分查在哪一行，第16列没有满足的值继续往前查。</span><br>            <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<span class="hljs-comment">//对第k列二分查找行</span><br>                mid = l + (r - l) / <span class="hljs-number">2</span>;<span class="hljs-comment">//二分行</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> f(mid, k,N);<br>                <span class="hljs-keyword">if</span> (x == N)<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; N)<br>                    r = mid - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    l = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (f(mid, k,N) == N)<br>            &#123;<span class="hljs-comment">//第mid行、第k列的数就是N</span><br>                System.out.println((mid + <span class="hljs-number">1</span>) * mid / <span class="hljs-number">2</span> + k + <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">//杨辉三角形的行数符号公差为1的等差数列，故用等差数列求和公式</span><br>                <span class="hljs-comment">//加上第几列再加上1（因为列从0开始）即可得出该数的位置</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        sc.close();<br> <br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">long</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">long</span> N)</span>&#123;   <span class="hljs-comment">//求c（i，j）的值,也就是i行j列的值</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a, j = <span class="hljs-number">1</span>; j &lt;= b; i--, j++)<br>            &#123;<br>                res = res * i / j;<br>                <span class="hljs-keyword">if</span> (res &gt; N )<span class="hljs-comment">//如果中间结果超过N就直接返回</span><br>                    <span class="hljs-keyword">return</span> res;<br>            &#125;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>路径（JAVA）</title>
    <link href="/2023/05/07/%E8%B7%AF%E5%BE%84%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/07/%E8%B7%AF%E5%BE%84%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p><strong>本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。</strong></p><p>小蓝学习了最短路径之后特别高兴，他定义了一个特别的图，希望找到图 中的最短路径。</p><p>小蓝的图由 2021 个结点组成，依次编号 1 至 2021。</p><p>对于两个不同的结点 a, b，如果 a 和 b 的差的绝对值大于 21，则两个结点 之间没有边相连；如果 a 和 b 的差的绝对值小于等于 21，则两个点之间有一条 长度为 a 和 b 的最小公倍数的无向边相连。</p><p>例如：结点 1 和结点 23 之间没有边相连；结点 3 和结点 24 之间有一条无 向边，长度为 24；结点 15 和结点 25 之间有一条无向边，长度为 75。</p><p>请计算，结点 1 和结点 2021 之间的最短路径长度是多少。</p><p>提示：建议使用计算机编程解决问题。</p><p><strong>运行限制</strong><br>最大运行时间：1s<br>最大运行内存: 128M</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> n=<span class="hljs-number">2022</span>;<br>        <span class="hljs-type">int</span>[] dp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];              <span class="hljs-comment">//n设为2022数组从1开始dp方便计算</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            dp[i]=Integer.MAX_VALUE;       <span class="hljs-comment">//给数组每个值都赋最大值，避免对接下来比较造成影响。</span><br>        &#125;<br>        dp[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;                           <span class="hljs-comment">//初始dp[1]赋值为1（dp数组的含义思路里会提到）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2020</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n&amp;&amp;(j-i&lt;=<span class="hljs-number">21</span>);j++)&#123;<br>                dp[j]=Math.min(dp[j],dp[i]+f(i,j));  <span class="hljs-comment">//从1开始将到达每个点的最短路径进行存储</span><br>            &#125;<br>        &#125;<br>        System.out.println(dp[<span class="hljs-number">2021</span>]);     <span class="hljs-comment">//输出dp[2021]</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;  <span class="hljs-comment">//求两个数的最小公倍数</span><br>        <span class="hljs-type">int</span> c=<span class="hljs-number">0</span>,d=a,e=b;<br>        <span class="hljs-keyword">while</span>(a%b!=<span class="hljs-number">0</span>)&#123;<br>            c=a%b;<br>            a=b;<br>            b=c;<br>        &#125;<br> <br>        <span class="hljs-keyword">return</span> d*e/b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>运用了动态规划（dp）的思想先解释一下dp数组的含义</p><p>dp[i]表示从1到i的最短距离。</p><p>当我们要求一个dp[i]的值时我们只需要比较取最小值即可，举个例子帮助理解。</p><p>比如我们要求dp[4],</p><p>则第一遍遍历dp[4]暂时为从1直接到4路径的长度（4），</p><p>第二遍遍历dp[4]的值为Math.min(从1直接到4的路径长度（4），从1到2的最短路径再加上2到4的路径长度（6）)，</p><p>第三次遍历dp[4]的值为Math.min(从1直接到4的路径长度（4），从1到3的最短路径加上3到4的路径长度（15）)</p><p>所以dp[4]最终&#x3D;4。</p><p>f方法是求小公倍数（先求a,b的最大公约数（假设是c）再求最小公倍数a*b&#x2F;c）然后求路径。</p><p>dp[2021]即为所求。</p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牌型种数（JAVA）</title>
    <link href="/2023/05/07/%E7%89%8C%E5%9E%8B%E7%A7%8D%E6%95%B0%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/07/%E7%89%8C%E5%9E%8B%E7%A7%8D%E6%95%B0%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p> <img src="/img/tupian03.png"></p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> result=<span class="hljs-number">0</span>;                <span class="hljs-comment">//储存结果种数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        select(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        System.out.println(result);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;   <span class="hljs-comment">//递归</span><br>        <span class="hljs-keyword">if</span> (x&gt;<span class="hljs-number">13</span>||y&gt;<span class="hljs-number">13</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (x==<span class="hljs-number">13</span>&amp;&amp;y==<span class="hljs-number">13</span>)&#123;<br>            result++;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;       <span class="hljs-comment">//0，1，2，3，4，共五种情况</span><br>            select(x+<span class="hljs-number">1</span>,y+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>可以拿十三次每次拿一张牌，但每张牌都要有十三种情况拿到所以复杂度是13^13复杂度过高。所以换一种思路</p><p>13种牌每张牌只有四张，所以我们拿十三张牌每种牌的个数可能是0，1，2，3，4张，共五种情况。</p><p>所以我们采取递归思想：</p><p>select(int x,int y);</p><p>x:目前在拿哪张牌（牌型）。</p><p>y:总共拿了多少张牌。</p><p>这样每张牌从十三种情况变为了五种，复杂度变为了5^13,并且如果在中途y&gt;13那么可以直接舍弃这种情况（比如1取了4张，2取了4张，3取了4张，4取了4张总共已经16张牌舍弃），如果取到了第十三种牌型的牌，而且总数正好是13则种数加1。</p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数位排序（JAVA）</title>
    <link href="/2023/05/07/%E6%95%B0%E4%BD%8D%E6%8E%92%E5%BA%8F%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/07/%E6%95%B0%E4%BD%8D%E6%8E%92%E5%BA%8F%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>小蓝对一个数的数位之和很感兴趣, 今天他要按照数位之和给数排序。当 两个数各个数位之和不同时, 将数位和较小的排在前面, 当数位之和相等时, 将数值小的排在前面。</p><p>例如, 2022 排在 409 前面, 因为 2022 的数位之和是 6, 小于 409 的数位 之和 13 。</p><p>又如, 6 排在 2022 前面, 因为它们的数位之和相同, 而 6 小于 2022 。</p><p>给定正整数n,m, 请问对 1 到 n 采用这种方法排序时, 排在第 m 个的元 素是多少?</p><p><strong>输入格式</strong><br>输入第一行包含一个正整数 n 。</p><p>第二行包含一个正整数 m 。</p><p><strong>输出格式</strong><br>输出一行包含一个整数, 表示答案。</p><p><strong>样例输入</strong></p><blockquote><p>13<br>5</p></blockquote><p><strong>样例输出</strong></p><blockquote><p>3</p></blockquote><p><strong>样例说明</strong><br>1 到 13 的排序为: 1,10,2,11,3,12,4,13,5,6,7,8,9 。第 5 个数为 3 。</p><p><strong>评测用例规模与约定</strong><br>对于30% 的评测用例,1≤m≤n≤300 。</p><p>对于50% 的评测用例, 1≤m≤n≤1000 。</p><p>对于所有评测用例, 1≤m≤n≤106 。</p><p><strong>运行限制</strong><br>最大运行时间：3s<br>最大运行内存: 512M</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> n,m;                         <br>        n=sc.nextInt();<br>        m=sc.nextInt();<br>        Integer[] arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[n];  <span class="hljs-comment">//必须用int的包装类Integer</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            arr[i]=i+<span class="hljs-number">1</span>;<br>        &#125;<br>        Arrays.sort(arr,((o1, o2) -&gt; js(o1)!=js(o2)?js(o1)-js(o2):o1-o2)); <span class="hljs-comment">//Lambda表达式用sort方法进行排序</span><br>        System.out.println(arr[m-<span class="hljs-number">1</span>]);<br>        sc.close();<br> <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">js</span><span class="hljs-params">(Integer a)</span>&#123;    <span class="hljs-comment">//求数位和</span><br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(a&gt;<span class="hljs-number">0</span>)&#123;<br>            sum+=a%<span class="hljs-number">10</span>;<br>            a=a/<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>本题用sort方法中的</p><p>sort(T[] a, Comparator&lt;? super T&gt; c)<br>根据指定的比较器引发的顺序对指定的对象数组进行排序</p><p> 此方法可以根据设置的条件交换元素的顺序，</p><p>Arrays.sort(arr,((o1, o2) -&gt; js(o1)!&#x3D;js(o2)?js(o1)-js(o2):o1-o2));<br>这段代码采用了Lambda表达式意思是比较前后两个数的数位和如果不同，则将数位和较小的放到前面，如果数位和相同则将较小的数字放到前面。</p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>青蛙过河（JAVA）</title>
    <link href="/2023/05/07/%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/07/%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>小青蛙住在一条河边, 它想到河对岸的学校去学习。小青蛙打算经过河里 的石头跳到对岸。</p><p>河里的石头排成了一条直线, 小青蛙每次跳跃必须落在一块石头或者岸上。 不过, 每块石头有一个高度, 每次小青蛙从一块石头起跳, 这块石头的高度就 会下降 1 , 当石头的高度下降到 0 时小青蛙不能再跳到这块石头上（某次跳跃 后使石头高度下降到 0 是允许的)。</p><p>小青蛙一共需要去学校上 x 天课, 所以它需要往返2x 次。当小青蛙具有 一个跳跃能力 y 时, 它能跳不超过 y 的距离。</p><p>请问小青蛙的跳跃能力至少是多少才能用这些石头上完 x 次课。</p><p><strong>输入格式</strong><br>输入的第一行包含两个整数 n,x, 分别表示河的宽度和小青蛙需要去学校 的天数。请注意 2x 才是实际过河的次数。</p><p>第二行包含 n−1 个非负整数H1,H2,⋯,Hn−1, 其中Hi&gt;0 表示在河中与 小青蛙的家相距 i 的地方有一块高度为 Hi 的石头, Hi&#x3D;0 表示这个位置没有石 头。</p><p><strong>输出格式</strong><br>输出一行, 包含一个整数, 表示小青蛙需要的最低跳跃能力。</p><p><strong>样例输入</strong></p><blockquote><p>5 1<br>1 0 1 0</p></blockquote><p><strong>样例输出</strong></p><blockquote><p>4</p></blockquote><p><strong>样例说明</strong><br>由于只有两块高度为 1 的石头，所以往返只能各用一块。第 1 块石头和对岸的距离为 4，如果小青蛙的跳跃能力为 3 则无法满足要求。所以小青蛙最少需要 4 的跳跃能力。</p><p><strong>评测用例规模与约定</strong><br>对于30% 的评测用例, n≤100;</p><p>对于 60% 的评测用例, n≤1000;</p><p>对于所有评测用例, 1≤n≤105,1≤x≤109,1≤Hi≤104 。</p><p><strong>运行限制</strong><br>最大运行时间：1s<br>最大运行内存: 512M</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> n,x;                  <span class="hljs-comment">//河的宽度和上学的天数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        n=sc.nextInt();<br>        x=sc.nextInt();<br>        <span class="hljs-type">int</span>[] H=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];          <span class="hljs-comment">//储存石头的位置以及高度</span><br>        <span class="hljs-type">int</span>[] b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];          <span class="hljs-comment">//储存每块石头之前可以跳跃的次数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            H[i]=sc.nextInt();<br>            sum+=H[i];<br>            b[i]=sum;<br>        &#125;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">1</span>,right=n,middle,S=<span class="hljs-number">0</span>;  <span class="hljs-comment">//二分法查找最小跳跃距离</span><br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            middle=left+right&gt;&gt;<span class="hljs-number">1</span>;       <span class="hljs-comment">//&gt;&gt;是位运算符X+Y&gt;&gt;1相当于(X+Y)/2</span><br>            <span class="hljs-keyword">if</span> (check(middle,b))&#123;<br>                S=middle;<br> <br>                right=middle-<span class="hljs-number">1</span>;<br> <br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                left=middle+<span class="hljs-number">1</span>;<br> <br>            &#125;<br> <br>        &#125;<br>        System.out.println(S);<br>        sc.close();<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> middle, <span class="hljs-type">int</span>[] b)</span> &#123;   <span class="hljs-comment">//查b集合的每个区间是否都有至少2*x个落脚点。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+middle&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span> (b[i+middle-<span class="hljs-number">1</span>]-b[i-<span class="hljs-number">1</span>]&lt;<span class="hljs-number">2</span>*x)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>这道题用了二分法的查找方法。</p><p>1.我们先进行一个转换，1只小青蛙去x天学校总共需要往返2<em>x次，转化为2</em>x只小青蛙过一次河。</p><p>2.我们将每块石头及之前石头可以跳跃的次数储存起来，以题目中给的例子为例，b[1]&#x3D;1,b[2]&#x3D;1,b[3]&#x3D;2,b[4]&#x3D;2。</p><p>3.采用二分法找最少跳跃距离，再一次次将midder（跳跃距离）在b集合的区间里找是否所有的区间都可以满足至少有2<em>x个落脚点（每次青蛙跳离一块石头后，之后的距离区间都要保证有2</em>x个落脚点，否则就会有青蛙跳不过去，所以要将所有区间都进行比较），如果可以先将midder储存起来（因为可能有更小的跳跃距离），再用二分法逐步比较，直到二分结束输出最终的最小跳跃距离。</p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求和（JAVA）</title>
    <link href="/2023/05/07/%E6%B1%82%E5%92%8C%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/07/%E6%B1%82%E5%92%8C%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给定 n 个整数 a1,a2,⋅⋅⋅,an ，求它们两两相乘再相加的和，即：</p><p>S&#x3D;a1⋅a2+a1⋅a3+⋯+a1⋅an+a2⋅a3+⋯+an−2⋅an−1+an−2⋅an+an−1⋅an</p><p><strong>输入格式</strong><br>输入的第一行包含一个整数 n。</p><p>第二行包含 n 个整数a1,a2,⋯,an。</p><p><strong>输出格式</strong><br>输出一个整数 S，表示所求的和。请使用合适的数据类型进行运算。</p><p><strong>样例输入</strong></p><blockquote><p>4<br>1 3 6 9</p></blockquote><p><strong>样例输出</strong></p><blockquote><p>117</p></blockquote><p><strong>评测用例规模与约定</strong><br>对于 30 %30% 的数据，1≤n≤1000,1≤ai≤100 。</p><p>对于所有评测用例， 1≤n≤200000,1≤ai≤1000 。</p><p><strong>运行限制</strong><br>最大运行时间：1s<br>最大运行内存: 512M</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> N;<br>        <span class="hljs-type">long</span> sum=<span class="hljs-number">0</span>,S=<span class="hljs-number">0</span>;                    <span class="hljs-comment">//sum储存数组中所有元素和，S储存最终结果。</span><br>        N=sc.nextInt();<br>        <span class="hljs-type">int</span>[] arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>            arr[i]=sc.nextInt();<br>            sum+=arr[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>            S+=arr[i]*(sum-arr[i]);<br>            sum-=arr[i];<br>            &#125;<br>        System.out.println(S);<br>            sc.close();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>看到题目我第一个想到的就是暴力解法，但1&lt;&#x3D;n&lt;&#x3D;200000,暴力解法肯定超时，所以我们要做一下优化。</p><p>题目给的试子还可以把a1到an-1提出来变成</p><p>a1*(a2+a3+……+an)+a2*(a3+a4+……+an)+…+an-1*an</p><p>我们发现提出来后括号中的试子都可以通过sum（所有数的和）减去之前的数得到。所以我们可以通过一个for循环解题。</p><p> for (int i &#x3D; 0; i &lt; N; i++) {<br>            S+&#x3D;arr[i]*(sum-arr[i]);<br>            sum-&#x3D;arr[i];<br>            }</p><p><strong>注：此代码提交后有时是100%通过有时不是，看其它题解也有人反应此问题，看其它题解思路都是相同的，代码应该没问题，应该是系统问题。</strong></p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>猜字母（JAVA）</title>
    <link href="/2023/05/07/%E7%8C%9C%E5%AD%97%E6%AF%8D%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/07/%E7%8C%9C%E5%AD%97%E6%AF%8D%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p><strong>本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。</strong></p><p>把 abcd…s 共19个字母组成的序列重复拼接 106 次，得到长度为 2014 的串。</p><p>接下来删除第 1 个字母（即开头的字母 a），以及第 3 个，第 5 个等所有奇数位置的字母。</p><p>得到的新字符串再进行删除奇数位置字母的动作。如此下去，最后只剩下一个字母，请输出该字母。</p><p><strong>运行限制</strong><br>最大运行时间：1s<br>最大运行内存: 128M</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> x=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span>[] arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">2014</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">106</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">19</span>;j++)&#123;<br>                arr[x++]=(<span class="hljs-type">char</span>)(<span class="hljs-string">&#x27;a&#x27;</span>+j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> length=<span class="hljs-number">2014</span>;<br>        <span class="hljs-keyword">while</span>(length!=<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-type">int</span> y=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;length;i+=<span class="hljs-number">2</span>)&#123;<br>                arr[y++]=arr[i];<br>            &#125;<br>            length=y;<br>        &#125;<br>        System.out.println(arr[<span class="hljs-number">0</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>将2014个字母组成的字符串储存在一个char类型的数组中，既然要删除奇数位的字母再重新组成新的字符串，那么我们就将偶数位的字母拿出来往前提放到数组之前，y为所有偶数位字母组成的新字符串的长度，当长度为1时输出数组中第一个字母即可。</p><p><strong>例：</strong>初始字符串：abcdefghijklmnopqrs</p><p>第一轮：bdfhjlnpr jklmnopqrs</p><p>第二轮：dhlp jlnprjklmnopqrs</p><p>第三轮：hp lpjlnprjklmnopqrs</p><p>第四轮：p plpjlnprjklmnopqrs</p><p>此时新组成的字符串长度为一结束</p><p>输出arr[0]&#x3D;p；</p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四平方和（JAVA）</title>
    <link href="/2023/05/07/%E5%9B%9B%E5%B9%B3%E6%96%B9%E5%92%8C%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/07/%E5%9B%9B%E5%B9%B3%E6%96%B9%E5%92%8C%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>四平方和定理，又称为拉格朗日定理：</p><p>每个正整数都可以表示为至多 4 个正整数的平方和。</p><p>如果把 0 包括进去，就正好可以表示为 4 个数的平方和。</p><p>比如：</p><p>5 &#x3D; 0^2 + 0^2 + 1^2 + 2^25；</p><p>7 &#x3D; 1^2 + 1^2 + 1^2 + 2^27；</p><p>对于一个给定的正整数，可能存在多种平方和的表示法。</p><p>要求你对 4 个数排序：</p><p>0≤a≤b≤c≤d</p><p>并对所有的可能表示法按 a,b,c,d 为联合主键升序排列，最后输出第一个表示法。</p><p><strong>输入描述</strong><br>程序输入为一个正整数 N(N&lt;5×10^6)。</p><p><strong>输出描述</strong><br>要求输出 4 个非负整数，按从小到大排序，中间用空格分开</p><p><strong>输入输出样例</strong><br>示例</p><p><strong>输入</strong></p><blockquote><p>12</p></blockquote><p>输出</p><blockquote><p>0 2 2 2</p></blockquote><p><strong>运行限制</strong><br>最大运行时间：3s<br>最大运行内存: 256M</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"> <br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        Map&lt;Integer,Integer&gt; cache=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-type">int</span> N;<br>        N=sc.nextInt();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c=<span class="hljs-number">0</span>;c*c&lt;=N/<span class="hljs-number">2</span>;c++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d=c;c*c+d*d&lt;=N;d++)&#123;<br>                <span class="hljs-keyword">if</span> (cache.get(c*c+d*d)==<span class="hljs-literal">null</span>)&#123;<br>                    cache.put(c*c+d*d,c);<br>                &#125;<br>            &#125;<br>        &#125;                                        <span class="hljs-comment">//对c，d进行遍历并存储</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;a*a&lt;=N/<span class="hljs-number">4</span>;a++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b=a;a*a+b*b&lt;=N/<span class="hljs-number">3</span>;b++)&#123;<br>                <span class="hljs-keyword">if</span> (cache.get(N-a*a-b*b)!=<span class="hljs-literal">null</span>)&#123;<br>                    <span class="hljs-type">int</span> c=cache.get(N-a*a-b*b);<br>                    <span class="hljs-type">int</span> d=(<span class="hljs-type">int</span>)Math.sqrt(N-a*a-b*b-c*c);<br>                    System.out.print(a+<span class="hljs-string">&quot; &quot;</span>+b+<span class="hljs-string">&quot; &quot;</span>+c+<span class="hljs-string">&quot; &quot;</span>+d);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>        &#125;                                       <span class="hljs-comment">//对a，b进行遍历并找到符合要求的a，b，c，d进行输出。</span><br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>看到题目首先想到的是暴力解法，a,b,c,d全部遍历一遍，因为0≤a≤b≤c≤d所以a&lt;&#x3D;N&#x2F;4,b&lt;&#x3D;N&#x2F;3,c&lt;&#x3D;N&#x2F;2,d&lt;&#x3D;N。但大约估计计算量为10^12必定会超时，所以我们需要优化算法。</p><p>我们将c,d和a,b分开来求，并将c，d得到的结果存储到Hashmap集合中，再去遍历a,b从map集合中寻找符合条件的值，这样就大大降低了计算量大约为10^6。</p><p><strong>并对所有的可能表示法按 a,b,c,d 为联合主键升序排列，最后输出第一个表示法。</strong></p><p>这句话其实就是让我们输出第一个找到的组合，再找到第一个组合后，进行输出直接停止就可以了。</p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>取球博弈（JAVA）</title>
    <link href="/2023/05/05/%E5%8F%96%E7%90%83%E5%8D%9A%E5%BC%88%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/05/%E5%8F%96%E7%90%83%E5%8D%9A%E5%BC%88%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>两个人玩取球的游戏。</p><p>一共有 N 个球，每人轮流取球，每次可取集合 n1,n2,n3中的任何一个数目。</p><p>如果无法继续取球，则游戏结束。</p><p>此时，持有奇数个球的一方获胜。</p><p>如果两人都是奇数，则为平局。</p><p>假设双方都采用最聪明的取法，</p><p>第一个取球的人一定能赢吗？</p><p>试编程解决这个问题。</p><p><strong>输入描述</strong><br>输入格式：</p><p>第一行 3 个正整数n1,n2,n3 (0&lt;n1,n2,n3&lt;100)，空格分开，表示每次可取的数目。</p><p>第二行 5 个正整数 x1,x2,⋯,x5 (0&lt;xi&lt;1000)，空格分开，表示 5 局的初始球数。</p><p><strong>输出描述</strong><br>输出一行 5 个字符，空格分开。分别表示每局先取球的人能否获胜。</p><p>能获胜则输出 +，次之，如有办法逼平对手，输出 0，无论如何都会输，则输出 -。</p><p><strong>输入输出样例</strong><br>示例</p><p><strong>输入</strong></p><blockquote><p>1 2 3<br>1 2 3 4 5</p></blockquote><p><strong>输出</strong></p><blockquote><p>+0 + 0 -</p></blockquote><p><strong>运行限制</strong><br>最大运行时间：3s<br>最大运行内存: 256M</p><h2 id="初始代码（会超时）："><a href="#初始代码（会超时）：" class="headerlink" title="初始代码（会超时）："></a>初始代码（会超时）：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">qu_qiu_bo_yi</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] N;                     <span class="hljs-comment">//全局变量存放可取集合</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        N=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        <span class="hljs-type">int</span>[] A=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];              <span class="hljs-comment">//存放5局的数目</span><br>        <span class="hljs-type">char</span>[] result=<span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">5</span>];       <span class="hljs-comment">//存放五局的结果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br>            N[i]=sc.nextInt();<br>        &#125;<br>        Arrays.sort(N);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>           A[i]=sc.nextInt();<br>           result[i]=f(A[i],<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            System.out.print(result[i]+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        sc.close();<br> <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">char</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> num,<span class="hljs-type">int</span> me,<span class="hljs-type">int</span> you)</span>&#123;  <span class="hljs-comment">//方法递归求结果，num：总球数，me：我手中的球数，you：对手手中的球数。</span><br>        <span class="hljs-keyword">if</span> (num&lt;N[<span class="hljs-number">0</span>])&#123;                    <span class="hljs-comment">//数组N已经过升序排列N[0]为最小的可取球数，若num&lt;N[0]则说明不能再取球了游戏结束，判断输赢。</span><br>            <span class="hljs-keyword">if</span> ((me&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>&amp;&amp;(you&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;+&#x27;</span>;               <span class="hljs-comment">//用位运算（下面会解释）判断奇数偶数并输出结果</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> ((me&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>&amp;&amp;(you&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;-&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">boolean</span> ping=<span class="hljs-literal">false</span>;             <span class="hljs-comment">//用于记录是否存在平局</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">3</span> ; i++) &#123;<br>            <span class="hljs-keyword">if</span> (num &gt;= N[i])&#123;<br>               <span class="hljs-type">char</span> result= f(num-N[i],you,me+N[i]);  <span class="hljs-comment">//因为是两个人博弈问题，所以每摸一次球就要换对方摸球，即me和you位置进行交换。</span><br>               <span class="hljs-keyword">if</span> (result==<span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>                   <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;+&#x27;</span>;          <span class="hljs-comment">//因为我们总是可以采取最聪明的方法所以只要对手有一种输的可能我们就必赢</span><br>               &#125;<br>               <span class="hljs-keyword">if</span> (result==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                   ping=<span class="hljs-literal">true</span>;           <span class="hljs-comment">//如果出现平局先记录下来</span><br>               &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ping==<span class="hljs-literal">true</span>)&#123;                <span class="hljs-comment">//如果可以走出循环走到这，那么就只有平局或必输，这里我们判断平局，ping为true则有平局的可能，因为我们总是可以采取最聪明的方法所以一定平局。</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;                       <span class="hljs-comment">//不赢也没办法平局则必输</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;-&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>首先解释一下位运算：</strong></p><p>&amp;运算符有两种用法：一种是为运算符；一种是逻辑运算符；</p><p>作为位运算符是进行二进制运算的，当两个对应位上都为1的时候才为1，否则为0</p><p>因为偶数二进制最后一位一定是0奇数最后一位一定是1，所以某个数n&amp;1&#x3D;&#x3D;1则n为奇数n&amp;1&#x3D;&#x3D;0则n为偶数。</p><p>比如2&amp;1 相当于010&amp;001结果为000&#x3D;0为偶数</p><p>3&amp;1相当于011&amp;001结果为001&#x3D;1为奇数。<br><strong>我们再说一下为什么会超时：</strong></p><p>因为xi最大为1000假设三个可取集合全为1，2，3则三个集合都可取三个集合取得的结果又有三种取法</p><p><img src="/img/tupian02.png"></p><p> 如图会有3^n种结果。</p><p>就会造成超时，那么我们就要想办法改进，这里要用到“记忆递归”顾名思义就是在其中的某个结点记录下它走到最后的结果，那么当在后面结点中遇到同样的情况就不用再次递归了。</p><h2 id="改进代码："><a href="#改进代码：" class="headerlink" title="改进代码："></a>改进代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">qu_qiu_bo_yi</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] N;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        N=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        <span class="hljs-type">int</span>[] A=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br>        <span class="hljs-type">char</span>[] result=<span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">5</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br>            N[i]=sc.nextInt();<br>        &#125;<br>        Arrays.sort(N);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>           A[i]=sc.nextInt();<br>           result[i]=f(A[i],<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            System.out.print(result[i]+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        sc.close();<br> <br>    &#125;                                           <span class="hljs-comment">//主函数没有改变</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">char</span>[][][] rem=<span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">1000</span>][<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];  <span class="hljs-comment">//用一个char类型的三维数组存储结果</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">char</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> num,<span class="hljs-type">int</span> me,<span class="hljs-type">int</span> you)</span>&#123;     <span class="hljs-comment">//这里me和you的含义改变了，因为我们并不需要知道两个人手中到底有多少颗求，只需要知道奇偶就可以判断结果，所以me：我手中球是奇数还是偶数，you：对手手中的球是奇数还是偶数。</span><br> <br>        <span class="hljs-keyword">if</span> (num&lt;N[<span class="hljs-number">0</span>])&#123;<br>            <span class="hljs-keyword">if</span> ((me&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>&amp;&amp;(you&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;+&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> ((me&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>&amp;&amp;(you&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;-&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>        &#125;                               <span class="hljs-comment">//同第一次代码判断奇偶输出结果</span><br>        <span class="hljs-keyword">if</span> (rem[num][me][you]!=<span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>            <span class="hljs-keyword">return</span> rem[num][me][you];<br>        &#125;                              <span class="hljs-comment">//在进行递归前先看rem三维数组中是否存在这种情况，如果有直接返回，没有继续递归。</span><br>        <span class="hljs-type">boolean</span> ping=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">3</span> ; i++) &#123;<br>            <span class="hljs-keyword">if</span> (num &gt;= N[i])&#123;<br>               <span class="hljs-type">char</span> result= f(num-N[i],you,(N[i]&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>?me:<span class="hljs-number">1</span>-me); <span class="hljs-comment">//判断取的球是奇数还是偶数，偶数的话还是0，奇数则变为1。因为只有0，1两种情况所以三维数组才可以定义为[1000][2][2]最多只有四千种情况。</span><br>               <span class="hljs-keyword">if</span> (result==<span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>                   rem[num][me][you]=<span class="hljs-string">&#x27;+&#x27;</span>;   <span class="hljs-comment">//记录这种情况的结果</span><br>                   <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;+&#x27;</span>;<br>               &#125;<br>               <span class="hljs-keyword">if</span> (result==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br> <br>                   ping=<span class="hljs-literal">true</span>;<br>               &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ping==<span class="hljs-literal">true</span>)&#123;<br>            rem[num][me][you]=<span class="hljs-string">&#x27;0&#x27;</span>;           <span class="hljs-comment">//记录这种情况的结果</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            rem[num][me][you]=<span class="hljs-string">&#x27;-&#x27;</span>;           <span class="hljs-comment">//记录这种情况的结果 </span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;-&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>包子凑数（JAVA）</title>
    <link href="/2023/05/05/%E5%8C%85%E5%AD%90%E5%87%91%E6%95%B0%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/05/%E5%8C%85%E5%AD%90%E5%87%91%E6%95%B0%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>小明几乎每天早晨都会在一家包子铺吃早餐。他发现这家包子铺有 N 种蒸笼，其中第 i 种蒸笼恰好能放Ai 个包子。每种蒸笼都有非常多笼，可以认为是无限笼。</p><p>每当有顾客想买 X 个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有 X 个包子。比如一共有 3 种蒸笼，分别能放 3、4 和 5 个包子。当顾客想买 11 个包子时，大叔就会选 2 笼 3 个的再加 1 笼 5 个的（也可能选出 1 笼 3 个的再加 2 笼 4 个的）。</p><p>当然有时包子大叔无论如何也凑不出顾客想买的数量。比如一共有 3 种蒸笼，分别能放 4、5 和 6 个包子。而顾客想买 7 个包子时，大叔就凑不出来了。</p><p>小明想知道一共有多少种数目是包子大叔凑不出来的。</p><p><strong>输入描述</strong><br>第一行包含一个整数 N （1≤N≤100)。</p><p>以下 N 行每行包含一个整数 Ai (1≤Ai≤100)。</p><p><strong>输出描述</strong><br>一个整数代表答案。如果凑不出的数目有无限多个，输出 INF。</p><p><strong>输入输出样例</strong><br>示例 1</p><p><strong>输入</strong></p><blockquote><p>2<br>4<br>5</p></blockquote><p><strong>输出</strong></p><blockquote><p>6</p></blockquote><p><strong>样例说明</strong></p><p>凑不出的数目包括：1, 2, 3, 6, 7, 11。</p><p>示例 2</p><p><strong>输入</strong></p><blockquote><p>2<br>4<br>6</p></blockquote><p><strong>输出</strong></p><blockquote><p>INF</p></blockquote><p><strong>样例说明</strong></p><p>所有奇数都凑不出来，所以有无限多个</p><p><strong>运行限制</strong><br>最大运行时间：1s<br>最大运行内存: 256M</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sc.nextInt();              <span class="hljs-comment">//n笼包子</span><br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;                         <span class="hljs-comment">//记录有多少数求不出来</span><br>        <span class="hljs-type">int</span>[] A = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];          <span class="hljs-comment">//每笼包子的包子数</span><br>        <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">10001</span>];  <span class="hljs-comment">//dp[i]=true表示i个包子可以拿出来</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            A[i] = sc.nextInt();<br>            dp[A[i]] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">yue</span> <span class="hljs-operator">=</span> A[<span class="hljs-number">1</span>];                    <span class="hljs-comment">//求最大公约数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n-<span class="hljs-number">1</span>; i++) &#123;<br>            yue=yueshu(yue,A[i+<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (yue!=<span class="hljs-number">1</span>)&#123;                       <span class="hljs-comment">//若最大公约数为1则这些数互为质数，若不互为质数，则会有无数种凑不出来的情况。</span><br>            System.out.println(<span class="hljs-string">&quot;INF&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;<span class="hljs-number">10001</span>;j++)&#123;<br>                <span class="hljs-keyword">if</span> (dp[j]&amp;&amp;j+A[i]&lt;=<span class="hljs-number">10000</span>)&#123;  <span class="hljs-comment">//动态规划若j个可以拿出来那么j+A[i]个包子也可以拿出来</span><br>                    dp[j+A[i]]=<span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">10001</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span> (!dp[i])&#123;<br>                sum++;<br>            &#125;<br>        &#125;<br>        System.out.println(sum);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">yueshu</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;  <span class="hljs-comment">//求最大公约数</span><br>        <span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> yueshu(y, x % y);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>本题采用动态规划思想，先介绍一下互为质数</p><p>互为质数：<strong>两个或多个数，最大公因数只有1，则称为互为质数。</strong></p><p>互为质数有一条性质：<strong>两个互质的数a和b最小不能表示的数就是(a-1)<em>(b-1)-1，也就是说两个互质的数a，b可以表示(a-1)</em>(b-1)之后的所有数字。</strong></p><p>所以我们通过判断这些数是否互为质数来判断是否有无限个结果。</p><p>dp的长度我们设为10001，因为如果dp长度过长会导致超时，而题目中A[i]&lt;&#x3D;100所以10001完全够用。</p><p>最后通过遍历如果j个包子可以拿出来，那么j+A[i]个包子也一定可以拿出来，最后将不能拿出来的数进行统计输出即可。</p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>等差数列（JAVA）</title>
    <link href="/2023/05/05/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/05/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>数学老师给小明出了一道等差数列求和的题目。但是粗心的小明忘记了一 部分的数列，只记得其中 N 个整数。</p><p>现在给出这 N 个整数，小明想知道包含这 N 个整数的最短的等差数列有几项？</p><p><strong>输入描述</strong><br>输入的第一行包含一个整数 N。</p><p>第二行包含 N 个整数A1,A2,⋅⋅⋅,AN。(注意A1 ∼ AN 并不一定是按等差数列中的顺序给出)</p><p>其中，2≤N≤10^5，0≤Ai≤10^9。</p><p><strong>输出描述</strong><br>输出一个整数表示答案。</p><p><strong>输入输出样例</strong><br>示例</p><p><strong>输入</strong></p><blockquote><p>5<br>2 6 4 10 20</p></blockquote><p><strong>输出</strong></p><blockquote><p>10</p></blockquote><blockquote><p>样例说明： 包含 2、6、4、10、20 的最短的等差数列是 2、4、6、8、10、12、14、16、 18、20。</p></blockquote><p><strong>运行限制</strong><br>最大运行时间：1s<br>最大运行内存: 256M</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> n;                           <span class="hljs-comment">//n个整数</span><br>        n=sc.nextInt();<br>        <span class="hljs-type">int</span>[] A=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];             <span class="hljs-comment">//存储n个整数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            A[i]=sc.nextInt();<br>        &#125;<br>        Arrays.sort(A);                  <span class="hljs-comment">//用sort方法进行升序排列</span><br>        <span class="hljs-type">int</span> min=Integer.MAX_VALUE;       <span class="hljs-comment">//min取最大值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n-<span class="hljs-number">1</span>;i++)&#123;<br>            min=Integer.min(min,A[i+<span class="hljs-number">1</span>]-A[i]); <span class="hljs-comment">//找出最小差值当作暂时的公差</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(min==<span class="hljs-number">0</span>)&#123;<br>            System.out.println(n);         <span class="hljs-comment">//特殊情况1：n个整数全部相同</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>,c=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--) &#123;      <br>                <span class="hljs-keyword">if</span> ((A[i] - A[<span class="hljs-number">0</span>]) % min != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//用等差数列的定义判断min是否为真正的公差</span><br>                    <span class="hljs-type">int</span>[] b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[min];<br>                     c=min;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x=<span class="hljs-number">2</span>;x&lt;=min/<span class="hljs-number">2</span>;x++)&#123;<br>                        <span class="hljs-keyword">if</span> (min%x==<span class="hljs-number">0</span>)&#123;<br>                            b[x]=x;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y=<span class="hljs-number">0</span>;y&lt;min;y++) &#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                            <span class="hljs-keyword">if</span> (b[y]!=<span class="hljs-number">0</span>&amp;&amp;(A[j] - A[<span class="hljs-number">0</span>]) % b[y] == <span class="hljs-number">0</span>)&#123;<br>                                c=b[y];<br> <br>                            &#125;<br> <br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (c==min)&#123;<br>                            a=A[n - <span class="hljs-number">1</span>] - A[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span>&#123;<br>                            a = (A[n - <span class="hljs-number">1</span>] - A[<span class="hljs-number">0</span>]) / c + <span class="hljs-number">1</span>; <span class="hljs-comment">//到这里以上因为min不是真正的公差所以用来判断是否为第二种特殊情况并赋值</span><br>                        &#125;<br>                    &#125;<br>                   <span class="hljs-keyword">break</span>;<br>                &#125;                 <br>            &#125;                          <br>            <span class="hljs-keyword">if</span> (a==<span class="hljs-number">0</span>) &#123; <br>                a = (A[n - <span class="hljs-number">1</span>] - A[<span class="hljs-number">0</span>]) / min + <span class="hljs-number">1</span>;   <span class="hljs-comment">//min为公差计算赋值</span><br>            &#125;<br>            System.out.println(a);<br>        &#125;<br>    &#125;<br> <br> <br> <br> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>因为无序所以先对其进行排序，用java自带的sort方法进行升序排序，然后找最小差值为暂时公差，如果最小差值是0，则为特殊情况1（n个整数都一样）直接输出n。</p><p>再利用等差数列定义判断min是否为公差：任意一个数Ai-最小的那个数A0）%（问题二求得的最小公差d）&#x3D;0则为公差，</p><p>这里会出现第二种特殊情况：如果两个不同的公差有公约数就会算错，比如输入数列5 15 30，输出的结果是26而不是6。</p><p>所以我们将min的全部约数求出来再进行一次判断如果有约数可以满足公差的要求，则最大满足要求的约数为新的公差进行计算。</p><p>a &#x3D; (A[n - 1] - A[0]) &#x2F; c + 1;<br>如果没有满足要求的约数则公差为1，</p><p>a&#x3D;A[n - 1] - A[0]+1;<br>如果min满足等差数列的定义，则min为真正的公差。<br>a &#x3D; (A[n - 1] - A[0]) &#x2F; min + 1;</p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>质数拆分（JAVA）</title>
    <link href="/2023/05/05/%E8%B4%A8%E6%95%B0%E6%8B%86%E5%88%86%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/05/%E8%B4%A8%E6%95%B0%E6%8B%86%E5%88%86%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p><strong>本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。</strong></p><p>将 2019 拆分为若干个两两不同的质数之和，一共有多少种不同的方法？</p><p>注意交换顺序视为同一种方法，例如 2+2017&#x3D;2019 与2017+2&#x3D;2019 视为同一种方法。</p><p><strong>运行限制</strong><br>最大运行时间：1s<br>最大运行内存: 128M</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-comment">// 1:无需package</span><br><span class="hljs-comment">// 2: 类名必须Main, 不可修改</span><br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br> <br>      <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> n=<span class="hljs-number">2500</span>;                  <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[]arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];         <span class="hljs-comment">//存放质数</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> dp[][]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n][n];   <span class="hljs-comment">//记录方案数</span><br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> cur=<span class="hljs-number">1</span>;                            <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;<span class="hljs-number">2019</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(ispre(i)) &#123;                   <span class="hljs-comment">//判断是否为质数进行存储</span><br>                arr[cur++]=i; <br>            &#125;<br>        &#125;<br>  <br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;cur;i++)&#123; <br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">2019</span>;j++)&#123; <br>                dp[i][j]=dp[i-<span class="hljs-number">1</span>][j];  <br>                <span class="hljs-keyword">if</span>(arr[i]&lt;=j)&#123; <br>                   <br>                    dp[i][j]+=dp[i-<span class="hljs-number">1</span>][j-arr[i]];     <span class="hljs-comment">//利用状态转移方程进行求解</span><br>                    <br>                &#125;<br>            &#125;<br> <br>        &#125;<br> <br>        System.out.println(dp[cur-<span class="hljs-number">1</span>][<span class="hljs-number">2019</span>]);<br> <br> <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">ispre</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=Math.sqrt(n);i++)&#123;<br>            <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;                                          <span class="hljs-comment">//判断是否是质数</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>本题采用动态规划，先将&lt;&#x3D;2019的质数存储到arr数组中。</p><p>dp[i][j]的含义是前i个质数组成j有几种方法我们在统计dp[i][j]时如果j&lt;arr[i]那么就说明j无法分解为arr[i]和另一个质数的和，那么dp[i][j]&#x3D;dp[i-1][j],因为前i个质数肯定包含了前i-1个质数。相反如果j&gt;&#x3D;arr[i]则dp[i][j]除了等于dp[i-1][j]外还要加上dp[i-1][j-arr[i]]，因为如果质数可以组成j-arr[i]则加上arr[i]也可以组成j。获得状态转移方程：</p><p>dp[i][j]&#x3D;dp[i-1][j]；</p><p>和</p><p>dp[i][j]&#x3D;dp[i-1][j]+dp[i-1][j-arr[i]];</p><p>利用这两个状态方程解题。</p><p>注：2019可以由多个质数组合而成不是必须两个。</p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k倍区间（JAVA）</title>
    <link href="/2023/05/05/k%E5%80%8D%E5%8C%BA%E9%97%B4%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/05/k%E5%80%8D%E5%8C%BA%E9%97%B4%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给定一个长度为 N 的数列，A1,A2,⋯AN，如果其中一段连续的子序列Ai,Ai+1,⋯Aj ( i≤j ) 之和是 K 的倍数，我们就称这个区间 [i,j] 是 K 倍区间。</p><p>你能求出数列中总共有多少个 K 倍区间吗？</p><p><strong>输入描述</strong><br>第一行包含两个整数 N 和 K( 1≤N,K≤100000)。</p><p>以下 N 行每行包含一个整数Ai ( 1≤Ai≤100000)</p><p><strong>输出描述</strong><br>输出一个整数，代表 K 倍区间的数目。</p><p><strong>输入输出样例</strong><br>示例</p><p><strong>输入</strong></p><blockquote><p>5 2<br>1<br>2<br>3<br>4<br>5</p></blockquote><p><strong>输出</strong></p><blockquote><p>6</p></blockquote><p><strong>运行限制</strong><br>最大运行时间：2s<br>最大运行内存: 256M</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">K</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span>[] A = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];           <span class="hljs-comment">//储存数列</span><br>        <span class="hljs-type">long</span>[] B = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">100000</span>];    <span class="hljs-comment">//储存同余的前缀和的个数</span><br>        <span class="hljs-type">long</span> sum=<span class="hljs-number">0</span>;                     <span class="hljs-comment">//计算前缀和</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;                <span class="hljs-comment">//储存结果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>            A[i]= sc.nextInt();<br>            sum+=A[i];<br>            B[(<span class="hljs-type">int</span>)(sum % K)]++;        <span class="hljs-comment">//前缀和取余并记数</span><br>        &#125;<br>        result=result+B[<span class="hljs-number">0</span>];             <span class="hljs-comment">//余数为零的区间一定是k倍区间</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;K;i++)&#123;<br>            result+=(B[i]*(B[i]-<span class="hljs-number">1</span>))/<span class="hljs-number">2</span>;  <span class="hljs-comment">//相同余数的前缀数相减得到的区间一定是K倍区间，再利用排列组合计算个数。</span><br>        &#125;<br>        System.out.println(result);<br>        sc.close();            <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>（1）前缀数（从序列第一个数到它自身的所有数之和）：比如例题中的序列1 2 3 4 5的前缀数分别是1 3 6 10 15。</p><p>（2）前缀数相减得到的区间：两个前缀数相减会得到一个区间比如5的前缀数15减去2的前缀数3可得到一个区间3 4 5。</p><p>（3）储存同余的前缀数：将所有前缀数对K取余将每个余数及其个数进行存储如B[1]&#x3D;3表示余数为1的前缀数有3个。</p><p>（4）两个同余的前缀数相减得到的区间一定是K倍区间：这算是一种数学规律如例题中15%2&#x3D;1，3%2&#x3D;1，（15-3）%2&#x3D;0也就是3 4 5是一个K倍区间。</p><p>（5）如果前缀数对K取余为0则说明这一区间必为K倍区间：如10%2&#x3D;0，则1 2 3 4必为一个K倍区间，</p><p>result&#x3D;result+B[0];直接加上即可。<br>（6）根据（4）可知任何两个同余的前缀数都可以获得一个前缀区间，则进行排列组合根据同余前缀数个数求出结果即可，还以例题为例B[1]&#x3D;3说明有三个余数是一的前缀数，我们要从中挑选两个组成一组求一个区间，共有C32（高中的排列组合3在下2在上）种组合方式为3*（3-1）&#x2F;2&#x3D;3，同理，余数为0的前缀（（5）计算的是从第一个数开始到它本身这个区间是k倍区间的个数所以并不冲突）数有1种组合方式加到一起总共有2+1&#x3D;3种再加上（5）中的2种共有6种。</p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回文日期（JAVA）</title>
    <link href="/2023/05/05/%E5%9B%9E%E6%96%87%E6%97%A5%E6%9C%9F%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/05/%E5%9B%9E%E6%96%87%E6%97%A5%E6%9C%9F%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>在日常生活中，通过年、月、日这三个要素可以表示出一个唯一确定的日期。</p><p>牛牛习惯用 8 位数字表示一个日期，其中，前 4 位代表年份，接下来 2 位代表月份，最后 2 位代表日期。显然：一个日期只有一种表示方法，而两个不同的日期的表示方法不会相同。</p><p>牛牛认为，一个日期是回文的，当且仅当表示这个日期的 8 位数字是回文的。现在，牛牛想知道：在他指定的两个日期之间包含这两个日期本身），有多少个真实存在的日期是回文的。</p><p>提示：</p><p>一个 8 位数字是回文的，当且仅当对于所有的i (1≤i≤8) 从左向右数的第 i 个数字和第 9 - i个数字（即从右向左数的第 i 个数字）是相同的。</p><p>例如：</p><p>对于 2016 年 11 月 19 日，用 8 位数字 20161119 表示，它不是回文的。</p><p>对于 2010 年 1 月 2 日，用 8 位数字 20100102 表示，它是回文的。</p><p>对于 2010 年 10 月 2 日，用 8 位数字 20101002 表示，它不是回文的。</p><p>每一年中都有 12 个月份：</p><p>其中，1,3,5,7,8,10,12 月每个月有 31 天；4,6,9,11 月每个月有 30 天；而对于 2 月，闰年时有 29 天，平年时有 28 天。</p><p>一个年份是闰年当且仅当它满足下列两种情况其中的一种：</p><p>这个年份是 4 的整数倍，但不是 100 的整数倍；</p><p>这个年份是 400 的整数倍。</p><p>例如：</p><p>以下几个年份都是闰年：2000,2012,2016。</p><p>以下几个年份是平年：1900,2011,2014。</p><p><strong>输入描述</strong><br>输入两行，每行包括一个 8 位数字。</p><p>第一行表示牛牛指定的起始日期。</p><p>第二行表示牛牛指定的终止日期。</p><p>保证 datei 和都是真实存在的日期，且年份部分一定为 4 位数字，且首位数字不为 0。</p><p>保证 date1 一定不晚于 date2。</p><p><strong>输出描述</strong><br>输出一个整数，表示在date1 和 date2 之间，有多少个日期是回文的。</p><p><strong>输入输出样例</strong><br>示例 1</p><p><strong>输入</strong></p><blockquote><p>20110101<br>20111231</p></blockquote><p><strong>输出</strong></p><blockquote><p>1</p></blockquote><p>示例 2</p><p><strong>输入</strong></p><blockquote><p>20000101<br>20101231</p></blockquote><p><strong>输出</strong></p><blockquote><p>2</p></blockquote><p><strong>运行限制</strong><br>最大运行时间：1s<br>最大运行内存: 256M</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Scanner scan=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>   <span class="hljs-type">int</span> date1,date2,result=<span class="hljs-number">0</span>;               <span class="hljs-comment">//date1为第一个数据，date2为第二个数据，result用来记录结果。</span><br>        <span class="hljs-type">int</span> [] yue=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">31</span>,<span class="hljs-number">29</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;;  <span class="hljs-comment">//将各个月份天数记录下来，二月记为29天从yue[1]为第一个月。</span><br>       date1=scan.nextInt();<br>       date2=scan.nextInt();<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">12</span>;i++)&#123;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=yue[i];j++)&#123;<br>           <span class="hljs-type">int</span> mm=i,dd=j,yyyy=dd%<span class="hljs-number">10</span>*<span class="hljs-number">1000</span>+dd/<span class="hljs-number">10</span>*<span class="hljs-number">100</span>+mm%<span class="hljs-number">10</span>*<span class="hljs-number">10</span>+mm/<span class="hljs-number">10</span>;  <span class="hljs-comment">//遍历月份和天数，通过计算得出回文日期对应的年份</span><br>           <span class="hljs-keyword">if</span> (yyyy&lt;<span class="hljs-number">1000</span>)&#123;<br>               <span class="hljs-keyword">continue</span>;                            <span class="hljs-comment">//如果年份不是四位数则跳过此次循环</span><br>           &#125;<br>           <span class="hljs-type">int</span> date3=yyyy*<span class="hljs-number">10000</span>+mm*<span class="hljs-number">100</span>+dd;          <span class="hljs-comment">//将得到的日期转换为八位数，与输入的两个数据作比较</span><br>           <span class="hljs-keyword">if</span> (date3&gt;=date1&amp;&amp;date3&lt;=date2)&#123;<br>               result++;                             <span class="hljs-comment">//得到结果</span><br>           &#125;<br>       &#125;<br>   &#125;<br>        System.out.println(result);<br> <br>        scan.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>可以将两个数据间全部日期进行遍历并判断是否为回文，但可能会超时，所以有两种改进方法</p><p>1.遍历年份</p><p>2.遍历月份和天数</p><p>因为闰年02月29日的回文日期为92200229符合要求，所以二月按照闰年来算，则最多循环366次即可得到全部的回文日期，在进行比较前再将算出的不足四位数的年份排除后进行比较，最后得出结果。</p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>作物杂交（JAVA）</title>
    <link href="/2023/05/05/%E4%BD%9C%E7%89%A9%E6%9D%82%E4%BA%A4%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/05/%E4%BD%9C%E7%89%A9%E6%9D%82%E4%BA%A4%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>作物杂交是作物栽培中重要的一步。已知有 N种作物 (编号 1至 N)，第 i种作物从播种到成熟的时间为 Ti。作物之间两两可以进行杂交，杂交时间取两种中时间较长的一方。如作物 A 种植时间为 5 天，作物 B 种植时间为 7 天，则 AB 杂交花费的时间为 7 天。作物杂交会产生固定的作物，新产生的作物仍然属于 N 种作物中的一种。</p><p>初始时，拥有其中 M 种作物的种子 (数量无限，可以支持多次杂交)。同时可以进行多个杂交过程。求问对于给定的目标种子，最少需要多少天能够得到。</p><p>如存在 4 种作物 ABCD，各自的成熟时间为 5 天、7 天、3 天、8 天。初始拥有 AB 两种作物的种子，目标种子为 D，已知杂交情况为 A × B → C，A × C → D。则最短的杂交过程为：</p><p>第 1 天到第 7 天 (作物 B 的时间)，A × B → C。</p><p>第 8 天到第 12 天 (作物 A 的时间)，A × C → D。</p><p>花费 12 天得到作物 D 的种子。<br><strong>输入描述</strong></p><p>输入的第 1 行包含 4 个整数 N, M, K, T，N 表示作物种类总数 (编号 1 至 N)，M 表示初始拥有的作物种子类型数量，K 表示可以杂交的方案数，T 表示目标种子的编号。</p><p>第 2 行包含 N 个整数，其中第 i 个整数表示第 i 种作物的种植时间 Ti (1≤Ti≤100)。</p><p>第 3 行包含 M 个整数，分别表示已拥有的种子类型 Kj (1≤Kj≤M)，Kj 两两不同。</p><p>第 4 至 K + 3 行，每行包含 3 个整数 A,B,C，表示第 A 类作物和第 B 类作物杂交可以获得第 C 类作物的种子。</p><p>其中， 1≤N≤2000,2≤M≤N,1≤K≤105,1≤T≤N, 保证目标种子一定可以通过杂交得到。<br><strong>输出描述</strong></p><p>输出一个整数，表示得到目标种子的最短杂交时间。</p><p><strong>输入输出样例</strong><br>示例</p><blockquote><p>输入</p></blockquote><blockquote><p>6 2 4 6<br>5 3 4 6 4 9<br>1 2<br>1 2 3<br>1 3 4<br>2 3 5<br>4 5 6</p></blockquote><blockquote><p>输出</p></blockquote><blockquote><p>16</p></blockquote><blockquote><p>样例说明</p></blockquote><p>第 1 天至第 5 天，将编号 1 与编号 2 的作物杂交，得到编号 3 的作物种子。</p><p>第 6 天至第 10 天，将编号 1 与编号 3 的作物杂交，得到编号 4 的作物种子。</p><p>第 6 天至第 9 天，将编号 2 与编号 3 的作物杂交，得到编号 5 的作物种子。</p><p>第 11 天至第 16 天，将编号 4 与编号 5 的作物杂交，得到编号 6 的作物种子。</p><p>总共花费 16 天。</p><p><strong>运行限制</strong><br>最大运行时间：2s<br>最大运行内存: 256M</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-comment">// 1:无需package</span><br><span class="hljs-comment">// 2: 类名必须Main, 不可修改</span><br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> N,M,K,T;     <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] time;         <span class="hljs-comment">//time数组记录每个作物的成熟时间</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span>[] flag;     <span class="hljs-comment">//用boolean类型的数组记录是否拥有某个作物的种子拥有记为true</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] line;       <span class="hljs-comment">//line为一个K行3列的二维数组用于存储合成方案</span><br>    <span class="hljs-keyword">static</span>  <span class="hljs-type">int</span> [] maxtime;    <span class="hljs-comment">//用于存储每种作物杂交所需要的成熟时间</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] res;          <span class="hljs-comment">//用于存储每种作物最终合成所需要的最终时间</span><br> <br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Scanner scan=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br> <br>        N=scan.nextInt();<br>        M=scan.nextInt();<br>        K=scan.nextInt();<br>        T=scan.nextInt();           <span class="hljs-comment">//第一行输入</span><br>        time=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N+<span class="hljs-number">1</span>];<br>        flag=<span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[N+<span class="hljs-number">1</span>];<br>        line=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[K][<span class="hljs-number">3</span>];<br>        maxtime=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[K];<br>        res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N+<span class="hljs-number">1</span>;i++)&#123;<br>            time[i]=scan.nextInt();  <span class="hljs-comment">//第二行输入</span><br>        &#125;<br> <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;M;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">seed</span> <span class="hljs-operator">=</span> scan.nextInt();<br>            flag[seed] = <span class="hljs-literal">true</span>;<br>        &#125;                             <span class="hljs-comment">//第三行输入</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;K;i++) &#123;<br>            line[i][<span class="hljs-number">0</span>]=scan.nextInt(); <span class="hljs-comment">// A</span><br>            line[i][<span class="hljs-number">1</span>]=scan.nextInt(); <span class="hljs-comment">// B</span><br>            line[i][<span class="hljs-number">2</span>]=scan.nextInt(); <span class="hljs-comment">// C</span><br>            maxtime[i]=Math.max(time[line[i][<span class="hljs-number">0</span>]],time[line[i][<span class="hljs-number">1</span>]]);<br>        &#125;                              <span class="hljs-comment">//第四行输入</span><br>        System.out.println(time(T));<br>        scan.close();<br> <br> <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">time</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;   <br>        <span class="hljs-keyword">if</span> (flag[index]==<span class="hljs-literal">false</span>)&#123;<br>           <span class="hljs-type">int</span> expend=Integer.MAX_VALUE;  <span class="hljs-comment">//记录时间选取最小值初始值为Integer.MAX_VALUE（表示int数据类型的最大取值数：2 147 483 647）防止在第一次比较时造成干扰</span><br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;K;i++)&#123;<br>               <span class="hljs-keyword">if</span> (line[i][<span class="hljs-number">2</span>]==index)&#123;<br>                   expend=Math.min(maxtime[i]+Math.max(time(line[i][<span class="hljs-number">0</span>]),time(line[i][<span class="hljs-number">1</span>])),expend);<br>               &#125;<br>           &#125;<br>           flag[index]=<span class="hljs-literal">true</span>;<br>           res[index]=expend;<br> <br>        &#125;<br>        <span class="hljs-keyword">return</span> res[index];<br>    &#125;                              <span class="hljs-comment">//time方法遍历加递归得出合成目标作物所需要的时间</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>本题采用了DFS(深度优先搜索算法)，先明确目标作物（以题目为例）</p><p>6需要4和5杂交需要6天。</p><p>4和5又需要继续向下杂交获得。</p><p>4需要1和3杂交需要5天。</p><p>5需要2和3杂交需要4天。</p><p>3需要继续杂交获得。</p><p>3需要1和2杂交获得需要5天。</p><p>所以得到4所需要天数为5+5&#x3D;10天。</p><p>得到5所需要天数为5+4&#x3D;9天。</p><p>只有得到4和5才能开始6的杂交工作所以只有在第10天才能开始6号作物的杂交即取获得4号作物和5号作物时间中的最大值。</p><p>所以获得6号作物所需要的天数为10+6&#x3D;16天。</p><p>1.由此可以分析出想得到6号作物需要它本身的杂交时间加上两个合成材料通过杂交获得时间中的最大值</p><p>2.本题中并未说明目标作物只有一种合成路径，测试用例中也确实出现了有多条合成路径的情况所以我们还需要从多条路径中选出用时最短的那一条</p><p>结合1.和2.可以得到：expend&#x3D;Math.min(maxtime[i]+Math.max(time(line[i][0]),time(line[i][1])),expend);再结合遍历和递归操作即可。</p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>砝码称重（JAVA）</title>
    <link href="/2023/05/05/%E7%A0%9D%E7%A0%81%E7%A7%B0%E9%87%8D%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/05/%E7%A0%9D%E7%A0%81%E7%A7%B0%E9%87%8D%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>你有一架天平和 N个砝码，这 N 个砝码重量依次是 W1, W2, · · · , WN。</p><p>请你计算一共可以称出多少种不同的重量？ 注意砝码可以放在天平两边。</p><p><strong>输入格式</strong></p><p>输入的第一行包含一个整数 N。</p><p>第二行包含 N 个整数：W1, W2, W3, · · · , WN。</p><p><strong>输出格式</strong></p><p>输出一个整数代表答案</p><p><strong>样例输入</strong></p><blockquote><p>3<br>1 4 6</p></blockquote><p><strong>样例输出</strong></p><blockquote><p>10</p></blockquote><p><strong>样例说明</strong></p><p>能称出的 10 种重量是：1、2、3、4、5、6、7、9、10、11。</p><p>1 &#x3D; 1；</p><p>2 &#x3D; 6 − 4 (2&#x3D;6−4(天平一边放 66，另一边放 4)；</p><p>3 &#x3D; 4 − 1；</p><p>4 &#x3D; 4；</p><p>5 &#x3D; 6 − 1；</p><p>6 &#x3D; 6；</p><p>7 &#x3D; 1 + 6；</p><p>9 &#x3D; 4 + 6 − 1；</p><p>10 &#x3D; 4 + 6；</p><p>11 &#x3D; 1 + 4 + 6。</p><p><strong>评测用规模与约定</strong></p><p>对于 50%的评测用例，1 ≤ N ≤ 15。</p><p>对于所有评测用例，1 ≤ N ≤ 100,N个砝码总重不超过 100000。</p><p><strong>运行限制</strong></p><ul><li>最大运行时间：1s</li><li>最大运行内存: 256M</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> N= sc.nextInt();<br>        <span class="hljs-type">int</span> fama[]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];     <span class="hljs-comment">//储存各砝码重量</span><br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;                 <span class="hljs-comment">//储存所有砝码可称出的最大重量</span><br>        <span class="hljs-type">int</span> max=<span class="hljs-number">0</span>;                 <span class="hljs-comment">//储存最多可以称出几种重量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>            fama[i]=sc.nextInt();<br>            sum+=fama[i];<br>        &#125;<br>        <span class="hljs-type">int</span> dp[][]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>*sum];  <span class="hljs-comment">//二维数组dp[i][j]  i表示前i个砝码j表示前i个砝码是否可以称出j的重量  设置成2*sum防止数组越界</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;               <span class="hljs-comment">//0个砝码一定可以称出0的重量所以直接设为1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=sum;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>                <span class="hljs-keyword">if</span> (dp[i-<span class="hljs-number">1</span>][j]==<span class="hljs-number">1</span>||dp[i-<span class="hljs-number">1</span>][Math.abs(j-fama[i-<span class="hljs-number">1</span>])]==<span class="hljs-number">1</span>||dp[i-<span class="hljs-number">1</span>][j+fama[i-<span class="hljs-number">1</span>]]==<span class="hljs-number">1</span>)&#123;<br>                    dp[i][j]=<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j]=<span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;                    <span class="hljs-comment">//先从第一个砝码开始在零个砝码的基础上放到天平左边减去此砝码重量放到右边加上此砝码重量，依次类推获得可以称出的所有重量。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>  j= <span class="hljs-number">1</span>; j&lt;= sum; j++)<br>            <span class="hljs-keyword">if</span>(dp[N][j]==<span class="hljs-number">1</span>) max++;<br>        System.out.println(max);  <span class="hljs-comment">//dp[N][j]==1时表示N个砝码可以称出j的重量由于重量0不算入最终结果所以j从1开始，则max加一最终输出max</span><br>        sc.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>运用dp(动态规划)思想，dp[i][j]表示i个砝码是否可以称出j的重量。</p><p>由于0个砝码一定可以称出0这个重量所以dp[0][0]&#x3D;&#x3D;1，之后在此基础上加入第一个砝码，放到天平左边则减去第一个砝码重量，放到右边则加上第一个砝码的重量依次类推得到N个砝码所能称出的所有重量（最终答案重量0排除在外所以从重量1开始遍历并进行统计）。</p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字三角形（JAVA）</title>
    <link href="/2023/05/02/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/02/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/img/tupian01.png" alt="说明图片"><br>上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。</p><p>路径上的每一步只能从一个数走到下一层和它最近的左边的那个数或者右 边的那个数。此外，向左下走的次数与向右下走的次数相差不能超过 1。</p><p><strong>输入描述</strong></p><p>输入的第一行包含一个整数 N (1≤N≤100)，表示三角形的行数。</p><p>下面的 N 行给出数字三角形。数字三角形上的数都是 0 至 100 之间的整数。</p><p><strong>输出描述</strong></p><p>输出一个整数，表示答案。</p><p><strong>输入输出样例</strong></p><p>示例</p><blockquote><p>输入</p></blockquote><p><code>5 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5</code></p><blockquote><p>输出</p></blockquote><p><code>27</code></p><p><strong>运行限制</strong></p><p>-最大运行时间：1S</p><p>-最大运行内存：256M</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> N=scan.nextInt();<br>        <span class="hljs-type">int</span>[][] arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [N][N];   <span class="hljs-comment">//二维数组arr储存数字三角形</span><br>        <span class="hljs-type">int</span>[][] pre=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][N];   <span class="hljs-comment">//二维数组pre储存路径，初始为零向左走减1向右走加1</span><br>        <span class="hljs-type">int</span>[][] dp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][N];    <span class="hljs-comment">//二维数组dp储存走到对应位置的最大和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;a&lt;=i;a++)&#123;<br>                arr[i][a]=scan.nextInt();<br>                pre[i][a]=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<span class="hljs-comment">//三角形顶点最大和就是它本身</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>]=dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+arr[i][<span class="hljs-number">0</span>];<br>            pre[i][<span class="hljs-number">0</span>]=pre[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-<span class="hljs-number">1</span>;<br>        &#125;                            <span class="hljs-comment">//只有通过arr[i-1][0]才能到达arr[i][0]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N;i++)&#123;<br>            dp[i][i]=dp[i-<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>]+arr[i][i];<br>            pre[i][i]=pre[i-<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>        &#125;                             <span class="hljs-comment">//只有通过arr[i-1][i-1]才能到达arr[i][i]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span> (dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]&gt;dp[i-<span class="hljs-number">1</span>][j])&#123;<br>                    pre[i][j]=pre[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>                    dp[i][j]=arr[i][j]+dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125;                     <br>                <span class="hljs-keyword">else</span>&#123;<br>                    pre[i][j]=pre[i-<span class="hljs-number">1</span>][j]-<span class="hljs-number">1</span>;<br>                    dp[i][j]=arr[i][j]+dp[i-<span class="hljs-number">1</span>][j];<br>                &#125;       <br> <br>            &#125;<br>        &#125;               <span class="hljs-comment">//arr[i][j]可以从arr[i-1][j-1]或arr[i-1][j]到达所以要比较找出最大值</span><br>        <span class="hljs-type">int</span>[] sum=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [N];   <span class="hljs-comment">//定义sum数组储存到达最底部符合条件的和初始为零</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>            sum[i]=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (pre[N-<span class="hljs-number">1</span>][i]&lt;=<span class="hljs-number">1</span>&amp;&amp;pre[N-<span class="hljs-number">1</span>][i]&gt;=-<span class="hljs-number">1</span>)&#123;<br>                sum[i]=dp[N-<span class="hljs-number">1</span>][i];<br>            &#125;                  <span class="hljs-comment">//pre二维数组记录路径只要为-1，0，1三个数就说明向左下和右下走的次数不超过1，记录数据最终进行比较</span><br> <br>        &#125;<br>        <span class="hljs-type">int</span> max=sum[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>            <span class="hljs-keyword">if</span>(max&lt;sum[i])&#123;<br>                max=sum[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                max=max;<br>            &#125;<br>        &#125;                  <br>        System.out.println(max);     <span class="hljs-comment">//通过比较选出最大路径并输出</span><br>        scan.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>将数字三角形转化到为二维数组中进行存储，由于最左侧一列和对角线都有固定的路径，再加以分析得到中间数字的路径从而获得三个状态转移方程（除去顶点）：</p><p>dp[i][0]&#x3D;dp[i-1][0]+arr[i][0];</p><p>dp[i][i]&#x3D;dp[i-1][i-1]+arr[i][i];</p><p>dp[i][j]&#x3D;max(dp[i-1][j-1],dp[i-1][j])+arr[i][j];</p><p>题目还对左下和右下走的次数有限制，因此我们用pre二维数组记录路径左下走-1右下走+1最终进行判断比较得出最大值并输出。</p><p><strong>CSDN</strong> <a href="https://blog.csdn.net/qq_63746090/article/details/129246539?spm=1001.2014.3001.5501">原文链接</a></p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/04/26/hello-world/"/>
    <url>/2023/04/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
