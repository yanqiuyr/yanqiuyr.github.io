<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>取球博弈（JAVA）</title>
    <link href="/2023/05/05/%E5%8F%96%E7%90%83%E5%8D%9A%E5%BC%88%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/05/%E5%8F%96%E7%90%83%E5%8D%9A%E5%BC%88%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>两个人玩取球的游戏。</p><p>一共有 N 个球，每人轮流取球，每次可取集合 n1,n2,n3中的任何一个数目。</p><p>如果无法继续取球，则游戏结束。</p><p>此时，持有奇数个球的一方获胜。</p><p>如果两人都是奇数，则为平局。</p><p>假设双方都采用最聪明的取法，</p><p>第一个取球的人一定能赢吗？</p><p>试编程解决这个问题。</p><p><strong>输入描述</strong><br>输入格式：</p><p>第一行 3 个正整数n1,n2,n3 (0&lt;n1,n2,n3&lt;100)，空格分开，表示每次可取的数目。</p><p>第二行 5 个正整数 x1,x2,⋯,x5 (0&lt;xi&lt;1000)，空格分开，表示 5 局的初始球数。</p><p><strong>输出描述</strong><br>输出一行 5 个字符，空格分开。分别表示每局先取球的人能否获胜。</p><p>能获胜则输出 +，次之，如有办法逼平对手，输出 0，无论如何都会输，则输出 -。</p><p><strong>输入输出样例</strong><br>示例</p><p><strong>输入</strong></p><blockquote><p>1 2 3<br>1 2 3 4 5</p></blockquote><p><strong>输出</strong></p><blockquote><p>+0 + 0 -</p></blockquote><p><strong>运行限制</strong><br>最大运行时间：3s<br>最大运行内存: 256M</p><h2 id="初始代码（会超时）："><a href="#初始代码（会超时）：" class="headerlink" title="初始代码（会超时）："></a>初始代码（会超时）：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">qu_qiu_bo_yi</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] N;                     <span class="hljs-comment">//全局变量存放可取集合</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        N=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        <span class="hljs-type">int</span>[] A=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];              <span class="hljs-comment">//存放5局的数目</span><br>        <span class="hljs-type">char</span>[] result=<span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">5</span>];       <span class="hljs-comment">//存放五局的结果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br>            N[i]=sc.nextInt();<br>        &#125;<br>        Arrays.sort(N);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>           A[i]=sc.nextInt();<br>           result[i]=f(A[i],<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            System.out.print(result[i]+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        sc.close();<br> <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">char</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> num,<span class="hljs-type">int</span> me,<span class="hljs-type">int</span> you)</span>&#123;  <span class="hljs-comment">//方法递归求结果，num：总球数，me：我手中的球数，you：对手手中的球数。</span><br>        <span class="hljs-keyword">if</span> (num&lt;N[<span class="hljs-number">0</span>])&#123;                    <span class="hljs-comment">//数组N已经过升序排列N[0]为最小的可取球数，若num&lt;N[0]则说明不能再取球了游戏结束，判断输赢。</span><br>            <span class="hljs-keyword">if</span> ((me&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>&amp;&amp;(you&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;+&#x27;</span>;               <span class="hljs-comment">//用位运算（下面会解释）判断奇数偶数并输出结果</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> ((me&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>&amp;&amp;(you&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;-&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">boolean</span> ping=<span class="hljs-literal">false</span>;             <span class="hljs-comment">//用于记录是否存在平局</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">3</span> ; i++) &#123;<br>            <span class="hljs-keyword">if</span> (num &gt;= N[i])&#123;<br>               <span class="hljs-type">char</span> result= f(num-N[i],you,me+N[i]);  <span class="hljs-comment">//因为是两个人博弈问题，所以每摸一次球就要换对方摸球，即me和you位置进行交换。</span><br>               <span class="hljs-keyword">if</span> (result==<span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>                   <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;+&#x27;</span>;          <span class="hljs-comment">//因为我们总是可以采取最聪明的方法所以只要对手有一种输的可能我们就必赢</span><br>               &#125;<br>               <span class="hljs-keyword">if</span> (result==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                   ping=<span class="hljs-literal">true</span>;           <span class="hljs-comment">//如果出现平局先记录下来</span><br>               &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ping==<span class="hljs-literal">true</span>)&#123;                <span class="hljs-comment">//如果可以走出循环走到这，那么就只有平局或必输，这里我们判断平局，ping为true则有平局的可能，因为我们总是可以采取最聪明的方法所以一定平局。</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;                       <span class="hljs-comment">//不赢也没办法平局则必输</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;-&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>首先解释一下位运算：</strong></p><p>&amp;运算符有两种用法：一种是为运算符；一种是逻辑运算符；</p><p>作为位运算符是进行二进制运算的，当两个对应位上都为1的时候才为1，否则为0</p><p>因为偶数二进制最后一位一定是0奇数最后一位一定是1，所以某个数n&amp;1&#x3D;&#x3D;1则n为奇数n&amp;1&#x3D;&#x3D;0则n为偶数。</p><p>比如2&amp;1 相当于010&amp;001结果为000&#x3D;0为偶数</p><p>3&amp;1相当于011&amp;001结果为001&#x3D;1为奇数。<br><strong>我们再说一下为什么会超时：</strong></p><p>因为xi最大为1000假设三个可取集合全为1，2，3则三个集合都可取三个集合取得的结果又有三种取法</p><p><img src="/img/tupian02.png"></p><p> 如图会有3^n种结果。</p><p>就会造成超时，那么我们就要想办法改进，这里要用到“记忆递归”顾名思义就是在其中的某个结点记录下它走到最后的结果，那么当在后面结点中遇到同样的情况就不用再次递归了。</p><h2 id="改进代码："><a href="#改进代码：" class="headerlink" title="改进代码："></a>改进代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">qu_qiu_bo_yi</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] N;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        N=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        <span class="hljs-type">int</span>[] A=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br>        <span class="hljs-type">char</span>[] result=<span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">5</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br>            N[i]=sc.nextInt();<br>        &#125;<br>        Arrays.sort(N);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>           A[i]=sc.nextInt();<br>           result[i]=f(A[i],<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            System.out.print(result[i]+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        sc.close();<br> <br>    &#125;                                           <span class="hljs-comment">//主函数没有改变</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">char</span>[][][] rem=<span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">1000</span>][<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];  <span class="hljs-comment">//用一个char类型的三维数组存储结果</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">char</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> num,<span class="hljs-type">int</span> me,<span class="hljs-type">int</span> you)</span>&#123;     <span class="hljs-comment">//这里me和you的含义改变了，因为我们并不需要知道两个人手中到底有多少颗求，只需要知道奇偶就可以判断结果，所以me：我手中球是奇数还是偶数，you：对手手中的球是奇数还是偶数。</span><br> <br>        <span class="hljs-keyword">if</span> (num&lt;N[<span class="hljs-number">0</span>])&#123;<br>            <span class="hljs-keyword">if</span> ((me&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>&amp;&amp;(you&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;+&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> ((me&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>&amp;&amp;(you&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;-&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>        &#125;                               <span class="hljs-comment">//同第一次代码判断奇偶输出结果</span><br>        <span class="hljs-keyword">if</span> (rem[num][me][you]!=<span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>            <span class="hljs-keyword">return</span> rem[num][me][you];<br>        &#125;                              <span class="hljs-comment">//在进行递归前先看rem三维数组中是否存在这种情况，如果有直接返回，没有继续递归。</span><br>        <span class="hljs-type">boolean</span> ping=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">3</span> ; i++) &#123;<br>            <span class="hljs-keyword">if</span> (num &gt;= N[i])&#123;<br>               <span class="hljs-type">char</span> result= f(num-N[i],you,(N[i]&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>?me:<span class="hljs-number">1</span>-me); <span class="hljs-comment">//判断取的球是奇数还是偶数，偶数的话还是0，奇数则变为1。因为只有0，1两种情况所以三维数组才可以定义为[1000][2][2]最多只有四千种情况。</span><br>               <span class="hljs-keyword">if</span> (result==<span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>                   rem[num][me][you]=<span class="hljs-string">&#x27;+&#x27;</span>;   <span class="hljs-comment">//记录这种情况的结果</span><br>                   <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;+&#x27;</span>;<br>               &#125;<br>               <span class="hljs-keyword">if</span> (result==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br> <br>                   ping=<span class="hljs-literal">true</span>;<br>               &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ping==<span class="hljs-literal">true</span>)&#123;<br>            rem[num][me][you]=<span class="hljs-string">&#x27;0&#x27;</span>;           <span class="hljs-comment">//记录这种情况的结果</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            rem[num][me][you]=<span class="hljs-string">&#x27;-&#x27;</span>;           <span class="hljs-comment">//记录这种情况的结果 </span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;-&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>包子凑数（JAVA）</title>
    <link href="/2023/05/05/%E5%8C%85%E5%AD%90%E5%87%91%E6%95%B0%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/05/%E5%8C%85%E5%AD%90%E5%87%91%E6%95%B0%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>小明几乎每天早晨都会在一家包子铺吃早餐。他发现这家包子铺有 N 种蒸笼，其中第 i 种蒸笼恰好能放Ai 个包子。每种蒸笼都有非常多笼，可以认为是无限笼。</p><p>每当有顾客想买 X 个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有 X 个包子。比如一共有 3 种蒸笼，分别能放 3、4 和 5 个包子。当顾客想买 11 个包子时，大叔就会选 2 笼 3 个的再加 1 笼 5 个的（也可能选出 1 笼 3 个的再加 2 笼 4 个的）。</p><p>当然有时包子大叔无论如何也凑不出顾客想买的数量。比如一共有 3 种蒸笼，分别能放 4、5 和 6 个包子。而顾客想买 7 个包子时，大叔就凑不出来了。</p><p>小明想知道一共有多少种数目是包子大叔凑不出来的。</p><p><strong>输入描述</strong><br>第一行包含一个整数 N （1≤N≤100)。</p><p>以下 N 行每行包含一个整数 Ai (1≤Ai≤100)。</p><p><strong>输出描述</strong><br>一个整数代表答案。如果凑不出的数目有无限多个，输出 INF。</p><p><strong>输入输出样例</strong><br>示例 1</p><p><strong>输入</strong></p><blockquote><p>2<br>4<br>5</p></blockquote><p><strong>输出</strong></p><blockquote><p>6</p></blockquote><p><strong>样例说明</strong></p><p>凑不出的数目包括：1, 2, 3, 6, 7, 11。</p><p>示例 2</p><p><strong>输入</strong></p><blockquote><p>2<br>4<br>6</p></blockquote><p><strong>输出</strong></p><blockquote><p>INF</p></blockquote><p><strong>样例说明</strong></p><p>所有奇数都凑不出来，所以有无限多个</p><p><strong>运行限制</strong><br>最大运行时间：1s<br>最大运行内存: 256M</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sc.nextInt();              <span class="hljs-comment">//n笼包子</span><br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;                         <span class="hljs-comment">//记录有多少数求不出来</span><br>        <span class="hljs-type">int</span>[] A = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];          <span class="hljs-comment">//每笼包子的包子数</span><br>        <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">10001</span>];  <span class="hljs-comment">//dp[i]=true表示i个包子可以拿出来</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            A[i] = sc.nextInt();<br>            dp[A[i]] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">yue</span> <span class="hljs-operator">=</span> A[<span class="hljs-number">1</span>];                    <span class="hljs-comment">//求最大公约数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n-<span class="hljs-number">1</span>; i++) &#123;<br>            yue=yueshu(yue,A[i+<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (yue!=<span class="hljs-number">1</span>)&#123;                       <span class="hljs-comment">//若最大公约数为1则这些数互为质数，若不互为质数，则会有无数种凑不出来的情况。</span><br>            System.out.println(<span class="hljs-string">&quot;INF&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;<span class="hljs-number">10001</span>;j++)&#123;<br>                <span class="hljs-keyword">if</span> (dp[j]&amp;&amp;j+A[i]&lt;=<span class="hljs-number">10000</span>)&#123;  <span class="hljs-comment">//动态规划若j个可以拿出来那么j+A[i]个包子也可以拿出来</span><br>                    dp[j+A[i]]=<span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">10001</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span> (!dp[i])&#123;<br>                sum++;<br>            &#125;<br>        &#125;<br>        System.out.println(sum);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">yueshu</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;  <span class="hljs-comment">//求最大公约数</span><br>        <span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> yueshu(y, x % y);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>本题采用动态规划思想，先介绍一下互为质数</p><p>互为质数：<strong>两个或多个数，最大公因数只有1，则称为互为质数。</strong></p><p>互为质数有一条性质：<strong>两个互质的数a和b最小不能表示的数就是(a-1)<em>(b-1)-1，也就是说两个互质的数a，b可以表示(a-1)</em>(b-1)之后的所有数字。</strong></p><p>所以我们通过判断这些数是否互为质数来判断是否有无限个结果。</p><p>dp的长度我们设为10001，因为如果dp长度过长会导致超时，而题目中A[i]&lt;&#x3D;100所以10001完全够用。</p><p>最后通过遍历如果j个包子可以拿出来，那么j+A[i]个包子也一定可以拿出来，最后将不能拿出来的数进行统计输出即可。</p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>等差数列（JAVA）</title>
    <link href="/2023/05/05/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/05/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>数学老师给小明出了一道等差数列求和的题目。但是粗心的小明忘记了一 部分的数列，只记得其中 N 个整数。</p><p>现在给出这 N 个整数，小明想知道包含这 N 个整数的最短的等差数列有几项？</p><p><strong>输入描述</strong><br>输入的第一行包含一个整数 N。</p><p>第二行包含 N 个整数A1,A2,⋅⋅⋅,AN。(注意A1 ∼ AN 并不一定是按等差数列中的顺序给出)</p><p>其中，2≤N≤10^5，0≤Ai≤10^9。</p><p><strong>输出描述</strong><br>输出一个整数表示答案。</p><p><strong>输入输出样例</strong><br>示例</p><p><strong>输入</strong></p><blockquote><p>5<br>2 6 4 10 20</p></blockquote><p><strong>输出</strong></p><blockquote><p>10</p></blockquote><blockquote><p>样例说明： 包含 2、6、4、10、20 的最短的等差数列是 2、4、6、8、10、12、14、16、 18、20。</p></blockquote><p><strong>运行限制</strong><br>最大运行时间：1s<br>最大运行内存: 256M</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> n;                           <span class="hljs-comment">//n个整数</span><br>        n=sc.nextInt();<br>        <span class="hljs-type">int</span>[] A=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];             <span class="hljs-comment">//存储n个整数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            A[i]=sc.nextInt();<br>        &#125;<br>        Arrays.sort(A);                  <span class="hljs-comment">//用sort方法进行升序排列</span><br>        <span class="hljs-type">int</span> min=Integer.MAX_VALUE;       <span class="hljs-comment">//min取最大值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n-<span class="hljs-number">1</span>;i++)&#123;<br>            min=Integer.min(min,A[i+<span class="hljs-number">1</span>]-A[i]); <span class="hljs-comment">//找出最小差值当作暂时的公差</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(min==<span class="hljs-number">0</span>)&#123;<br>            System.out.println(n);         <span class="hljs-comment">//特殊情况1：n个整数全部相同</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>,c=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--) &#123;      <br>                <span class="hljs-keyword">if</span> ((A[i] - A[<span class="hljs-number">0</span>]) % min != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//用等差数列的定义判断min是否为真正的公差</span><br>                    <span class="hljs-type">int</span>[] b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[min];<br>                     c=min;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x=<span class="hljs-number">2</span>;x&lt;=min/<span class="hljs-number">2</span>;x++)&#123;<br>                        <span class="hljs-keyword">if</span> (min%x==<span class="hljs-number">0</span>)&#123;<br>                            b[x]=x;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y=<span class="hljs-number">0</span>;y&lt;min;y++) &#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                            <span class="hljs-keyword">if</span> (b[y]!=<span class="hljs-number">0</span>&amp;&amp;(A[j] - A[<span class="hljs-number">0</span>]) % b[y] == <span class="hljs-number">0</span>)&#123;<br>                                c=b[y];<br> <br>                            &#125;<br> <br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (c==min)&#123;<br>                            a=A[n - <span class="hljs-number">1</span>] - A[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span>&#123;<br>                            a = (A[n - <span class="hljs-number">1</span>] - A[<span class="hljs-number">0</span>]) / c + <span class="hljs-number">1</span>; <span class="hljs-comment">//到这里以上因为min不是真正的公差所以用来判断是否为第二种特殊情况并赋值</span><br>                        &#125;<br>                    &#125;<br>                   <span class="hljs-keyword">break</span>;<br>                &#125;                 <br>            &#125;                          <br>            <span class="hljs-keyword">if</span> (a==<span class="hljs-number">0</span>) &#123; <br>                a = (A[n - <span class="hljs-number">1</span>] - A[<span class="hljs-number">0</span>]) / min + <span class="hljs-number">1</span>;   <span class="hljs-comment">//min为公差计算赋值</span><br>            &#125;<br>            System.out.println(a);<br>        &#125;<br>    &#125;<br> <br> <br> <br> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>因为无序所以先对其进行排序，用java自带的sort方法进行升序排序，然后找最小差值为暂时公差，如果最小差值是0，则为特殊情况1（n个整数都一样）直接输出n。</p><p>再利用等差数列定义判断min是否为公差：任意一个数Ai-最小的那个数A0）%（问题二求得的最小公差d）&#x3D;0则为公差，</p><p>这里会出现第二种特殊情况：如果两个不同的公差有公约数就会算错，比如输入数列5 15 30，输出的结果是26而不是6。</p><p>所以我们将min的全部约数求出来再进行一次判断如果有约数可以满足公差的要求，则最大满足要求的约数为新的公差进行计算。</p><p>a &#x3D; (A[n - 1] - A[0]) &#x2F; c + 1;<br>如果没有满足要求的约数则公差为1，</p><p>a&#x3D;A[n - 1] - A[0]+1;<br>如果min满足等差数列的定义，则min为真正的公差。<br>a &#x3D; (A[n - 1] - A[0]) &#x2F; min + 1;</p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>质数拆分（JAVA）</title>
    <link href="/2023/05/05/%E8%B4%A8%E6%95%B0%E6%8B%86%E5%88%86%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/05/%E8%B4%A8%E6%95%B0%E6%8B%86%E5%88%86%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p><strong>本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。</strong></p><p>将 2019 拆分为若干个两两不同的质数之和，一共有多少种不同的方法？</p><p>注意交换顺序视为同一种方法，例如 2+2017&#x3D;2019 与2017+2&#x3D;2019 视为同一种方法。</p><p><strong>运行限制</strong><br>最大运行时间：1s<br>最大运行内存: 128M</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-comment">// 1:无需package</span><br><span class="hljs-comment">// 2: 类名必须Main, 不可修改</span><br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br> <br>      <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> n=<span class="hljs-number">2500</span>;                  <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[]arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];         <span class="hljs-comment">//存放质数</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> dp[][]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n][n];   <span class="hljs-comment">//记录方案数</span><br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> cur=<span class="hljs-number">1</span>;                            <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;<span class="hljs-number">2019</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(ispre(i)) &#123;                   <span class="hljs-comment">//判断是否为质数进行存储</span><br>                arr[cur++]=i; <br>            &#125;<br>        &#125;<br>  <br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;cur;i++)&#123; <br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">2019</span>;j++)&#123; <br>                dp[i][j]=dp[i-<span class="hljs-number">1</span>][j];  <br>                <span class="hljs-keyword">if</span>(arr[i]&lt;=j)&#123; <br>                   <br>                    dp[i][j]+=dp[i-<span class="hljs-number">1</span>][j-arr[i]];     <span class="hljs-comment">//利用状态转移方程进行求解</span><br>                    <br>                &#125;<br>            &#125;<br> <br>        &#125;<br> <br>        System.out.println(dp[cur-<span class="hljs-number">1</span>][<span class="hljs-number">2019</span>]);<br> <br> <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">ispre</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=Math.sqrt(n);i++)&#123;<br>            <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;                                          <span class="hljs-comment">//判断是否是质数</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>本题采用动态规划，先将&lt;&#x3D;2019的质数存储到arr数组中。</p><p>dp[i][j]的含义是前i个质数组成j有几种方法我们在统计dp[i][j]时如果j&lt;arr[i]那么就说明j无法分解为arr[i]和另一个质数的和，那么dp[i][j]&#x3D;dp[i-1][j],因为前i个质数肯定包含了前i-1个质数。相反如果j&gt;&#x3D;arr[i]则dp[i][j]除了等于dp[i-1][j]外还要加上dp[i-1][j-arr[i]]，因为如果质数可以组成j-arr[i]则加上arr[i]也可以组成j。获得状态转移方程：</p><p>dp[i][j]&#x3D;dp[i-1][j]；</p><p>和</p><p>dp[i][j]&#x3D;dp[i-1][j]+dp[i-1][j-arr[i]];</p><p>利用这两个状态方程解题。</p><p>注：2019可以由多个质数组合而成不是必须两个。</p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k倍区间（JAVA）</title>
    <link href="/2023/05/05/k%E5%80%8D%E5%8C%BA%E9%97%B4%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/05/k%E5%80%8D%E5%8C%BA%E9%97%B4%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给定一个长度为 N 的数列，A1,A2,⋯AN，如果其中一段连续的子序列Ai,Ai+1,⋯Aj ( i≤j ) 之和是 K 的倍数，我们就称这个区间 [i,j] 是 K 倍区间。</p><p>你能求出数列中总共有多少个 K 倍区间吗？</p><p><strong>输入描述</strong><br>第一行包含两个整数 N 和 K( 1≤N,K≤100000)。</p><p>以下 N 行每行包含一个整数Ai ( 1≤Ai≤100000)</p><p><strong>输出描述</strong><br>输出一个整数，代表 K 倍区间的数目。</p><p><strong>输入输出样例</strong><br>示例</p><p><strong>输入</strong></p><blockquote><p>5 2<br>1<br>2<br>3<br>4<br>5</p></blockquote><p><strong>输出</strong></p><blockquote><p>6</p></blockquote><p><strong>运行限制</strong><br>最大运行时间：2s<br>最大运行内存: 256M</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">K</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span>[] A = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];           <span class="hljs-comment">//储存数列</span><br>        <span class="hljs-type">long</span>[] B = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">100000</span>];    <span class="hljs-comment">//储存同余的前缀和的个数</span><br>        <span class="hljs-type">long</span> sum=<span class="hljs-number">0</span>;                     <span class="hljs-comment">//计算前缀和</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;                <span class="hljs-comment">//储存结果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>            A[i]= sc.nextInt();<br>            sum+=A[i];<br>            B[(<span class="hljs-type">int</span>)(sum % K)]++;        <span class="hljs-comment">//前缀和取余并记数</span><br>        &#125;<br>        result=result+B[<span class="hljs-number">0</span>];             <span class="hljs-comment">//余数为零的区间一定是k倍区间</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;K;i++)&#123;<br>            result+=(B[i]*(B[i]-<span class="hljs-number">1</span>))/<span class="hljs-number">2</span>;  <span class="hljs-comment">//相同余数的前缀数相减得到的区间一定是K倍区间，再利用排列组合计算个数。</span><br>        &#125;<br>        System.out.println(result);<br>        sc.close();            <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>（1）前缀数（从序列第一个数到它自身的所有数之和）：比如例题中的序列1 2 3 4 5的前缀数分别是1 3 6 10 15。</p><p>（2）前缀数相减得到的区间：两个前缀数相减会得到一个区间比如5的前缀数15减去2的前缀数3可得到一个区间3 4 5。</p><p>（3）储存同余的前缀数：将所有前缀数对K取余将每个余数及其个数进行存储如B[1]&#x3D;3表示余数为1的前缀数有3个。</p><p>（4）两个同余的前缀数相减得到的区间一定是K倍区间：这算是一种数学规律如例题中15%2&#x3D;1，3%2&#x3D;1，（15-3）%2&#x3D;0也就是3 4 5是一个K倍区间。</p><p>（5）如果前缀数对K取余为0则说明这一区间必为K倍区间：如10%2&#x3D;0，则1 2 3 4必为一个K倍区间，</p><p>result&#x3D;result+B[0];直接加上即可。<br>（6）根据（4）可知任何两个同余的前缀数都可以获得一个前缀区间，则进行排列组合根据同余前缀数个数求出结果即可，还以例题为例B[1]&#x3D;3说明有三个余数是一的前缀数，我们要从中挑选两个组成一组求一个区间，共有C32（高中的排列组合3在下2在上）种组合方式为3*（3-1）&#x2F;2&#x3D;3，同理，余数为0的前缀（（5）计算的是从第一个数开始到它本身这个区间是k倍区间的个数所以并不冲突）数有1种组合方式加到一起总共有2+1&#x3D;3种再加上（5）中的2种共有6种。</p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回文日期（JAVA）</title>
    <link href="/2023/05/05/%E5%9B%9E%E6%96%87%E6%97%A5%E6%9C%9F%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/05/%E5%9B%9E%E6%96%87%E6%97%A5%E6%9C%9F%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>在日常生活中，通过年、月、日这三个要素可以表示出一个唯一确定的日期。</p><p>牛牛习惯用 8 位数字表示一个日期，其中，前 4 位代表年份，接下来 2 位代表月份，最后 2 位代表日期。显然：一个日期只有一种表示方法，而两个不同的日期的表示方法不会相同。</p><p>牛牛认为，一个日期是回文的，当且仅当表示这个日期的 8 位数字是回文的。现在，牛牛想知道：在他指定的两个日期之间包含这两个日期本身），有多少个真实存在的日期是回文的。</p><p>提示：</p><p>一个 8 位数字是回文的，当且仅当对于所有的i (1≤i≤8) 从左向右数的第 i 个数字和第 9 - i个数字（即从右向左数的第 i 个数字）是相同的。</p><p>例如：</p><p>对于 2016 年 11 月 19 日，用 8 位数字 20161119 表示，它不是回文的。</p><p>对于 2010 年 1 月 2 日，用 8 位数字 20100102 表示，它是回文的。</p><p>对于 2010 年 10 月 2 日，用 8 位数字 20101002 表示，它不是回文的。</p><p>每一年中都有 12 个月份：</p><p>其中，1,3,5,7,8,10,12 月每个月有 31 天；4,6,9,11 月每个月有 30 天；而对于 2 月，闰年时有 29 天，平年时有 28 天。</p><p>一个年份是闰年当且仅当它满足下列两种情况其中的一种：</p><p>这个年份是 4 的整数倍，但不是 100 的整数倍；</p><p>这个年份是 400 的整数倍。</p><p>例如：</p><p>以下几个年份都是闰年：2000,2012,2016。</p><p>以下几个年份是平年：1900,2011,2014。</p><p><strong>输入描述</strong><br>输入两行，每行包括一个 8 位数字。</p><p>第一行表示牛牛指定的起始日期。</p><p>第二行表示牛牛指定的终止日期。</p><p>保证 datei 和都是真实存在的日期，且年份部分一定为 4 位数字，且首位数字不为 0。</p><p>保证 date1 一定不晚于 date2。</p><p><strong>输出描述</strong><br>输出一个整数，表示在date1 和 date2 之间，有多少个日期是回文的。</p><p><strong>输入输出样例</strong><br>示例 1</p><p><strong>输入</strong></p><blockquote><p>20110101<br>20111231</p></blockquote><p><strong>输出</strong></p><blockquote><p>1</p></blockquote><p>示例 2</p><p><strong>输入</strong></p><blockquote><p>20000101<br>20101231</p></blockquote><p><strong>输出</strong></p><blockquote><p>2</p></blockquote><p><strong>运行限制</strong><br>最大运行时间：1s<br>最大运行内存: 256M</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Scanner scan=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>   <span class="hljs-type">int</span> date1,date2,result=<span class="hljs-number">0</span>;               <span class="hljs-comment">//date1为第一个数据，date2为第二个数据，result用来记录结果。</span><br>        <span class="hljs-type">int</span> [] yue=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">31</span>,<span class="hljs-number">29</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;;  <span class="hljs-comment">//将各个月份天数记录下来，二月记为29天从yue[1]为第一个月。</span><br>       date1=scan.nextInt();<br>       date2=scan.nextInt();<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">12</span>;i++)&#123;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=yue[i];j++)&#123;<br>           <span class="hljs-type">int</span> mm=i,dd=j,yyyy=dd%<span class="hljs-number">10</span>*<span class="hljs-number">1000</span>+dd/<span class="hljs-number">10</span>*<span class="hljs-number">100</span>+mm%<span class="hljs-number">10</span>*<span class="hljs-number">10</span>+mm/<span class="hljs-number">10</span>;  <span class="hljs-comment">//遍历月份和天数，通过计算得出回文日期对应的年份</span><br>           <span class="hljs-keyword">if</span> (yyyy&lt;<span class="hljs-number">1000</span>)&#123;<br>               <span class="hljs-keyword">continue</span>;                            <span class="hljs-comment">//如果年份不是四位数则跳过此次循环</span><br>           &#125;<br>           <span class="hljs-type">int</span> date3=yyyy*<span class="hljs-number">10000</span>+mm*<span class="hljs-number">100</span>+dd;          <span class="hljs-comment">//将得到的日期转换为八位数，与输入的两个数据作比较</span><br>           <span class="hljs-keyword">if</span> (date3&gt;=date1&amp;&amp;date3&lt;=date2)&#123;<br>               result++;                             <span class="hljs-comment">//得到结果</span><br>           &#125;<br>       &#125;<br>   &#125;<br>        System.out.println(result);<br> <br>        scan.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>可以将两个数据间全部日期进行遍历并判断是否为回文，但可能会超时，所以有两种改进方法</p><p>1.遍历年份</p><p>2.遍历月份和天数</p><p>因为闰年02月29日的回文日期为92200229符合要求，所以二月按照闰年来算，则最多循环366次即可得到全部的回文日期，在进行比较前再将算出的不足四位数的年份排除后进行比较，最后得出结果。</p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>作物杂交（JAVA）</title>
    <link href="/2023/05/05/%E4%BD%9C%E7%89%A9%E6%9D%82%E4%BA%A4%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/05/%E4%BD%9C%E7%89%A9%E6%9D%82%E4%BA%A4%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>作物杂交是作物栽培中重要的一步。已知有 N种作物 (编号 1至 N)，第 i种作物从播种到成熟的时间为 Ti。作物之间两两可以进行杂交，杂交时间取两种中时间较长的一方。如作物 A 种植时间为 5 天，作物 B 种植时间为 7 天，则 AB 杂交花费的时间为 7 天。作物杂交会产生固定的作物，新产生的作物仍然属于 N 种作物中的一种。</p><p>初始时，拥有其中 M 种作物的种子 (数量无限，可以支持多次杂交)。同时可以进行多个杂交过程。求问对于给定的目标种子，最少需要多少天能够得到。</p><p>如存在 4 种作物 ABCD，各自的成熟时间为 5 天、7 天、3 天、8 天。初始拥有 AB 两种作物的种子，目标种子为 D，已知杂交情况为 A × B → C，A × C → D。则最短的杂交过程为：</p><p>第 1 天到第 7 天 (作物 B 的时间)，A × B → C。</p><p>第 8 天到第 12 天 (作物 A 的时间)，A × C → D。</p><p>花费 12 天得到作物 D 的种子。<br><strong>输入描述</strong></p><p>输入的第 1 行包含 4 个整数 N, M, K, T，N 表示作物种类总数 (编号 1 至 N)，M 表示初始拥有的作物种子类型数量，K 表示可以杂交的方案数，T 表示目标种子的编号。</p><p>第 2 行包含 N 个整数，其中第 i 个整数表示第 i 种作物的种植时间 Ti (1≤Ti≤100)。</p><p>第 3 行包含 M 个整数，分别表示已拥有的种子类型 Kj (1≤Kj≤M)，Kj 两两不同。</p><p>第 4 至 K + 3 行，每行包含 3 个整数 A,B,C，表示第 A 类作物和第 B 类作物杂交可以获得第 C 类作物的种子。</p><p>其中， 1≤N≤2000,2≤M≤N,1≤K≤105,1≤T≤N, 保证目标种子一定可以通过杂交得到。<br><strong>输出描述</strong></p><p>输出一个整数，表示得到目标种子的最短杂交时间。</p><p><strong>输入输出样例</strong><br>示例</p><blockquote><p>输入</p></blockquote><blockquote><p>6 2 4 6<br>5 3 4 6 4 9<br>1 2<br>1 2 3<br>1 3 4<br>2 3 5<br>4 5 6</p></blockquote><blockquote><p>输出</p></blockquote><blockquote><p>16</p></blockquote><blockquote><p>样例说明</p></blockquote><p>第 1 天至第 5 天，将编号 1 与编号 2 的作物杂交，得到编号 3 的作物种子。</p><p>第 6 天至第 10 天，将编号 1 与编号 3 的作物杂交，得到编号 4 的作物种子。</p><p>第 6 天至第 9 天，将编号 2 与编号 3 的作物杂交，得到编号 5 的作物种子。</p><p>第 11 天至第 16 天，将编号 4 与编号 5 的作物杂交，得到编号 6 的作物种子。</p><p>总共花费 16 天。</p><p><strong>运行限制</strong><br>最大运行时间：2s<br>最大运行内存: 256M</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-comment">// 1:无需package</span><br><span class="hljs-comment">// 2: 类名必须Main, 不可修改</span><br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> N,M,K,T;     <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] time;         <span class="hljs-comment">//time数组记录每个作物的成熟时间</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span>[] flag;     <span class="hljs-comment">//用boolean类型的数组记录是否拥有某个作物的种子拥有记为true</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] line;       <span class="hljs-comment">//line为一个K行3列的二维数组用于存储合成方案</span><br>    <span class="hljs-keyword">static</span>  <span class="hljs-type">int</span> [] maxtime;    <span class="hljs-comment">//用于存储每种作物杂交所需要的成熟时间</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] res;          <span class="hljs-comment">//用于存储每种作物最终合成所需要的最终时间</span><br> <br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Scanner scan=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br> <br>        N=scan.nextInt();<br>        M=scan.nextInt();<br>        K=scan.nextInt();<br>        T=scan.nextInt();           <span class="hljs-comment">//第一行输入</span><br>        time=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N+<span class="hljs-number">1</span>];<br>        flag=<span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[N+<span class="hljs-number">1</span>];<br>        line=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[K][<span class="hljs-number">3</span>];<br>        maxtime=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[K];<br>        res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N+<span class="hljs-number">1</span>;i++)&#123;<br>            time[i]=scan.nextInt();  <span class="hljs-comment">//第二行输入</span><br>        &#125;<br> <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;M;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">seed</span> <span class="hljs-operator">=</span> scan.nextInt();<br>            flag[seed] = <span class="hljs-literal">true</span>;<br>        &#125;                             <span class="hljs-comment">//第三行输入</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;K;i++) &#123;<br>            line[i][<span class="hljs-number">0</span>]=scan.nextInt(); <span class="hljs-comment">// A</span><br>            line[i][<span class="hljs-number">1</span>]=scan.nextInt(); <span class="hljs-comment">// B</span><br>            line[i][<span class="hljs-number">2</span>]=scan.nextInt(); <span class="hljs-comment">// C</span><br>            maxtime[i]=Math.max(time[line[i][<span class="hljs-number">0</span>]],time[line[i][<span class="hljs-number">1</span>]]);<br>        &#125;                              <span class="hljs-comment">//第四行输入</span><br>        System.out.println(time(T));<br>        scan.close();<br> <br> <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">time</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;   <br>        <span class="hljs-keyword">if</span> (flag[index]==<span class="hljs-literal">false</span>)&#123;<br>           <span class="hljs-type">int</span> expend=Integer.MAX_VALUE;  <span class="hljs-comment">//记录时间选取最小值初始值为Integer.MAX_VALUE（表示int数据类型的最大取值数：2 147 483 647）防止在第一次比较时造成干扰</span><br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;K;i++)&#123;<br>               <span class="hljs-keyword">if</span> (line[i][<span class="hljs-number">2</span>]==index)&#123;<br>                   expend=Math.min(maxtime[i]+Math.max(time(line[i][<span class="hljs-number">0</span>]),time(line[i][<span class="hljs-number">1</span>])),expend);<br>               &#125;<br>           &#125;<br>           flag[index]=<span class="hljs-literal">true</span>;<br>           res[index]=expend;<br> <br>        &#125;<br>        <span class="hljs-keyword">return</span> res[index];<br>    &#125;                              <span class="hljs-comment">//time方法遍历加递归得出合成目标作物所需要的时间</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>本题采用了DFS(深度优先搜索算法)，先明确目标作物（以题目为例）</p><p>6需要4和5杂交需要6天。</p><p>4和5又需要继续向下杂交获得。</p><p>4需要1和3杂交需要5天。</p><p>5需要2和3杂交需要4天。</p><p>3需要继续杂交获得。</p><p>3需要1和2杂交获得需要5天。</p><p>所以得到4所需要天数为5+5&#x3D;10天。</p><p>得到5所需要天数为5+4&#x3D;9天。</p><p>只有得到4和5才能开始6的杂交工作所以只有在第10天才能开始6号作物的杂交即取获得4号作物和5号作物时间中的最大值。</p><p>所以获得6号作物所需要的天数为10+6&#x3D;16天。</p><p>1.由此可以分析出想得到6号作物需要它本身的杂交时间加上两个合成材料通过杂交获得时间中的最大值</p><p>2.本题中并未说明目标作物只有一种合成路径，测试用例中也确实出现了有多条合成路径的情况所以我们还需要从多条路径中选出用时最短的那一条</p><p>结合1.和2.可以得到：expend&#x3D;Math.min(maxtime[i]+Math.max(time(line[i][0]),time(line[i][1])),expend);再结合遍历和递归操作即可。</p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>砝码称重（JAVA）</title>
    <link href="/2023/05/05/%E7%A0%9D%E7%A0%81%E7%A7%B0%E9%87%8D%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/05/%E7%A0%9D%E7%A0%81%E7%A7%B0%E9%87%8D%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>你有一架天平和 N个砝码，这 N 个砝码重量依次是 W1, W2, · · · , WN。</p><p>请你计算一共可以称出多少种不同的重量？ 注意砝码可以放在天平两边。</p><p><strong>输入格式</strong></p><p>输入的第一行包含一个整数 N。</p><p>第二行包含 N 个整数：W1, W2, W3, · · · , WN。</p><p><strong>输出格式</strong></p><p>输出一个整数代表答案</p><p><strong>样例输入</strong></p><blockquote><p>3<br>1 4 6</p></blockquote><p><strong>样例输出</strong></p><blockquote><p>10</p></blockquote><p><strong>样例说明</strong></p><p>能称出的 10 种重量是：1、2、3、4、5、6、7、9、10、11。</p><p>1 &#x3D; 1；</p><p>2 &#x3D; 6 − 4 (2&#x3D;6−4(天平一边放 66，另一边放 4)；</p><p>3 &#x3D; 4 − 1；</p><p>4 &#x3D; 4；</p><p>5 &#x3D; 6 − 1；</p><p>6 &#x3D; 6；</p><p>7 &#x3D; 1 + 6；</p><p>9 &#x3D; 4 + 6 − 1；</p><p>10 &#x3D; 4 + 6；</p><p>11 &#x3D; 1 + 4 + 6。</p><p><strong>评测用规模与约定</strong></p><p>对于 50%的评测用例，1 ≤ N ≤ 15。</p><p>对于所有评测用例，1 ≤ N ≤ 100,N个砝码总重不超过 100000。</p><p><strong>运行限制</strong></p><ul><li>最大运行时间：1s</li><li>最大运行内存: 256M</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> N= sc.nextInt();<br>        <span class="hljs-type">int</span> fama[]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];     <span class="hljs-comment">//储存各砝码重量</span><br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;                 <span class="hljs-comment">//储存所有砝码可称出的最大重量</span><br>        <span class="hljs-type">int</span> max=<span class="hljs-number">0</span>;                 <span class="hljs-comment">//储存最多可以称出几种重量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>            fama[i]=sc.nextInt();<br>            sum+=fama[i];<br>        &#125;<br>        <span class="hljs-type">int</span> dp[][]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>*sum];  <span class="hljs-comment">//二维数组dp[i][j]  i表示前i个砝码j表示前i个砝码是否可以称出j的重量  设置成2*sum防止数组越界</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;               <span class="hljs-comment">//0个砝码一定可以称出0的重量所以直接设为1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=sum;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>                <span class="hljs-keyword">if</span> (dp[i-<span class="hljs-number">1</span>][j]==<span class="hljs-number">1</span>||dp[i-<span class="hljs-number">1</span>][Math.abs(j-fama[i-<span class="hljs-number">1</span>])]==<span class="hljs-number">1</span>||dp[i-<span class="hljs-number">1</span>][j+fama[i-<span class="hljs-number">1</span>]]==<span class="hljs-number">1</span>)&#123;<br>                    dp[i][j]=<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j]=<span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;                    <span class="hljs-comment">//先从第一个砝码开始在零个砝码的基础上放到天平左边减去此砝码重量放到右边加上此砝码重量，依次类推获得可以称出的所有重量。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>  j= <span class="hljs-number">1</span>; j&lt;= sum; j++)<br>            <span class="hljs-keyword">if</span>(dp[N][j]==<span class="hljs-number">1</span>) max++;<br>        System.out.println(max);  <span class="hljs-comment">//dp[N][j]==1时表示N个砝码可以称出j的重量由于重量0不算入最终结果所以j从1开始，则max加一最终输出max</span><br>        sc.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>运用dp(动态规划)思想，dp[i][j]表示i个砝码是否可以称出j的重量。</p><p>由于0个砝码一定可以称出0这个重量所以dp[0][0]&#x3D;&#x3D;1，之后在此基础上加入第一个砝码，放到天平左边则减去第一个砝码重量，放到右边则加上第一个砝码的重量依次类推得到N个砝码所能称出的所有重量（最终答案重量0排除在外所以从重量1开始遍历并进行统计）。</p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字三角形（JAVA）</title>
    <link href="/2023/05/02/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/02/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/img/tupian01.png" alt="说明图片"><br>上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。</p><p>路径上的每一步只能从一个数走到下一层和它最近的左边的那个数或者右 边的那个数。此外，向左下走的次数与向右下走的次数相差不能超过 1。</p><p><strong>输入描述</strong></p><p>输入的第一行包含一个整数 N (1≤N≤100)，表示三角形的行数。</p><p>下面的 N 行给出数字三角形。数字三角形上的数都是 0 至 100 之间的整数。</p><p><strong>输出描述</strong></p><p>输出一个整数，表示答案。</p><p><strong>输入输出样例</strong></p><p>示例</p><blockquote><p>输入</p></blockquote><p><code>5 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5</code></p><blockquote><p>输出</p></blockquote><p><code>27</code></p><p><strong>运行限制</strong></p><p>-最大运行时间：1S</p><p>-最大运行内存：256M</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> N=scan.nextInt();<br>        <span class="hljs-type">int</span>[][] arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [N][N];   <span class="hljs-comment">//二维数组arr储存数字三角形</span><br>        <span class="hljs-type">int</span>[][] pre=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][N];   <span class="hljs-comment">//二维数组pre储存路径，初始为零向左走减1向右走加1</span><br>        <span class="hljs-type">int</span>[][] dp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][N];    <span class="hljs-comment">//二维数组dp储存走到对应位置的最大和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;a&lt;=i;a++)&#123;<br>                arr[i][a]=scan.nextInt();<br>                pre[i][a]=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<span class="hljs-comment">//三角形顶点最大和就是它本身</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>]=dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+arr[i][<span class="hljs-number">0</span>];<br>            pre[i][<span class="hljs-number">0</span>]=pre[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-<span class="hljs-number">1</span>;<br>        &#125;                            <span class="hljs-comment">//只有通过arr[i-1][0]才能到达arr[i][0]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N;i++)&#123;<br>            dp[i][i]=dp[i-<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>]+arr[i][i];<br>            pre[i][i]=pre[i-<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>        &#125;                             <span class="hljs-comment">//只有通过arr[i-1][i-1]才能到达arr[i][i]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span> (dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]&gt;dp[i-<span class="hljs-number">1</span>][j])&#123;<br>                    pre[i][j]=pre[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>                    dp[i][j]=arr[i][j]+dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125;                     <br>                <span class="hljs-keyword">else</span>&#123;<br>                    pre[i][j]=pre[i-<span class="hljs-number">1</span>][j]-<span class="hljs-number">1</span>;<br>                    dp[i][j]=arr[i][j]+dp[i-<span class="hljs-number">1</span>][j];<br>                &#125;       <br> <br>            &#125;<br>        &#125;               <span class="hljs-comment">//arr[i][j]可以从arr[i-1][j-1]或arr[i-1][j]到达所以要比较找出最大值</span><br>        <span class="hljs-type">int</span>[] sum=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [N];   <span class="hljs-comment">//定义sum数组储存到达最底部符合条件的和初始为零</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>            sum[i]=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (pre[N-<span class="hljs-number">1</span>][i]&lt;=<span class="hljs-number">1</span>&amp;&amp;pre[N-<span class="hljs-number">1</span>][i]&gt;=-<span class="hljs-number">1</span>)&#123;<br>                sum[i]=dp[N-<span class="hljs-number">1</span>][i];<br>            &#125;                  <span class="hljs-comment">//pre二维数组记录路径只要为-1，0，1三个数就说明向左下和右下走的次数不超过1，记录数据最终进行比较</span><br> <br>        &#125;<br>        <span class="hljs-type">int</span> max=sum[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>            <span class="hljs-keyword">if</span>(max&lt;sum[i])&#123;<br>                max=sum[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                max=max;<br>            &#125;<br>        &#125;                  <br>        System.out.println(max);     <span class="hljs-comment">//通过比较选出最大路径并输出</span><br>        scan.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>将数字三角形转化到为二维数组中进行存储，由于最左侧一列和对角线都有固定的路径，再加以分析得到中间数字的路径从而获得三个状态转移方程（除去顶点）：</p><p>dp[i][0]&#x3D;dp[i-1][0]+arr[i][0];</p><p>dp[i][i]&#x3D;dp[i-1][i-1]+arr[i][i];</p><p>dp[i][j]&#x3D;max(dp[i-1][j-1],dp[i-1][j])+arr[i][j];</p><p>题目还对左下和右下走的次数有限制，因此我们用pre二维数组记录路径左下走-1右下走+1最终进行判断比较得出最大值并输出。</p><p><strong>CSDN</strong> <a href="https://blog.csdn.net/qq_63746090/article/details/129246539?spm=1001.2014.3001.5501">原文链接</a></p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/04/26/hello-world/"/>
    <url>/2023/04/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
