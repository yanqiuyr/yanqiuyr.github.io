<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>砝码称重（JAVA）</title>
    <link href="/2023/05/05/%E7%A0%9D%E7%A0%81%E7%A7%B0%E9%87%8D%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/05/%E7%A0%9D%E7%A0%81%E7%A7%B0%E9%87%8D%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>你有一架天平和 N个砝码，这 N 个砝码重量依次是 W1, W2, · · · , WN。</p><p>请你计算一共可以称出多少种不同的重量？ 注意砝码可以放在天平两边。</p><p><strong>输入格式</strong></p><p>输入的第一行包含一个整数 N。</p><p>第二行包含 N 个整数：W1, W2, W3, · · · , WN。</p><p><strong>输出格式</strong></p><p>输出一个整数代表答案</p><p><strong>样例输入</strong></p><blockquote><p>3<br>1 4 6</p></blockquote><p><strong>样例输出</strong></p><blockquote><p>10</p></blockquote><p><strong>样例说明</strong></p><p>能称出的 10 种重量是：1、2、3、4、5、6、7、9、10、11。</p><p>1 &#x3D; 1；</p><p>2 &#x3D; 6 − 4 (2&#x3D;6−4(天平一边放 66，另一边放 4)；</p><p>3 &#x3D; 4 − 1；</p><p>4 &#x3D; 4；</p><p>5 &#x3D; 6 − 1；</p><p>6 &#x3D; 6；</p><p>7 &#x3D; 1 + 6；</p><p>9 &#x3D; 4 + 6 − 1；</p><p>10 &#x3D; 4 + 6；</p><p>11 &#x3D; 1 + 4 + 6。</p><p><strong>评测用规模与约定</strong></p><p>对于 50%的评测用例，1 ≤ N ≤ 15。</p><p>对于所有评测用例，1 ≤ N ≤ 100,N个砝码总重不超过 100000。</p><p><strong>运行限制</strong></p><ul><li>最大运行时间：1s</li><li>最大运行内存: 256M</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> N= sc.nextInt();<br>        <span class="hljs-type">int</span> fama[]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];     <span class="hljs-comment">//储存各砝码重量</span><br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;                 <span class="hljs-comment">//储存所有砝码可称出的最大重量</span><br>        <span class="hljs-type">int</span> max=<span class="hljs-number">0</span>;                 <span class="hljs-comment">//储存最多可以称出几种重量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>            fama[i]=sc.nextInt();<br>            sum+=fama[i];<br>        &#125;<br>        <span class="hljs-type">int</span> dp[][]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>*sum];  <span class="hljs-comment">//二维数组dp[i][j]  i表示前i个砝码j表示前i个砝码是否可以称出j的重量  设置成2*sum防止数组越界</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;               <span class="hljs-comment">//0个砝码一定可以称出0的重量所以直接设为1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=sum;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>                <span class="hljs-keyword">if</span> (dp[i-<span class="hljs-number">1</span>][j]==<span class="hljs-number">1</span>||dp[i-<span class="hljs-number">1</span>][Math.abs(j-fama[i-<span class="hljs-number">1</span>])]==<span class="hljs-number">1</span>||dp[i-<span class="hljs-number">1</span>][j+fama[i-<span class="hljs-number">1</span>]]==<span class="hljs-number">1</span>)&#123;<br>                    dp[i][j]=<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j]=<span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;                    <span class="hljs-comment">//先从第一个砝码开始在零个砝码的基础上放到天平左边减去此砝码重量放到右边加上此砝码重量，依次类推获得可以称出的所有重量。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>  j= <span class="hljs-number">1</span>; j&lt;= sum; j++)<br>            <span class="hljs-keyword">if</span>(dp[N][j]==<span class="hljs-number">1</span>) max++;<br>        System.out.println(max);  <span class="hljs-comment">//dp[N][j]==1时表示N个砝码可以称出j的重量由于重量0不算入最终结果所以j从1开始，则max加一最终输出max</span><br>        sc.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>运用dp(动态规划)思想，dp[i][j]表示i个砝码是否可以称出j的重量。</p><p>由于0个砝码一定可以称出0这个重量所以dp[0][0]&#x3D;&#x3D;1，之后在此基础上加入第一个砝码，放到天平左边则减去第一个砝码重量，放到右边则加上第一个砝码的重量依次类推得到N个砝码所能称出的所有重量（最终答案重量0排除在外所以从重量1开始遍历并进行统计）。</p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字三角形（JAVA）</title>
    <link href="/2023/05/02/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88JAVA%EF%BC%89/"/>
    <url>/2023/05/02/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88JAVA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/img/tupian01.png" alt="说明图片"><br>上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。</p><p>路径上的每一步只能从一个数走到下一层和它最近的左边的那个数或者右 边的那个数。此外，向左下走的次数与向右下走的次数相差不能超过 1。</p><p><strong>输入描述</strong></p><p>输入的第一行包含一个整数 N (1≤N≤100)，表示三角形的行数。</p><p>下面的 N 行给出数字三角形。数字三角形上的数都是 0 至 100 之间的整数。</p><p><strong>输出描述</strong></p><p>输出一个整数，表示答案。</p><p><strong>输入输出样例</strong></p><p>示例</p><blockquote><p>输入</p></blockquote><p><code>5 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5</code></p><blockquote><p>输出</p></blockquote><p><code>27</code></p><p><strong>运行限制</strong></p><p>-最大运行时间：1S</p><p>-最大运行内存：256M</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> N=scan.nextInt();<br>        <span class="hljs-type">int</span>[][] arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [N][N];   <span class="hljs-comment">//二维数组arr储存数字三角形</span><br>        <span class="hljs-type">int</span>[][] pre=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][N];   <span class="hljs-comment">//二维数组pre储存路径，初始为零向左走减1向右走加1</span><br>        <span class="hljs-type">int</span>[][] dp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][N];    <span class="hljs-comment">//二维数组dp储存走到对应位置的最大和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;a&lt;=i;a++)&#123;<br>                arr[i][a]=scan.nextInt();<br>                pre[i][a]=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<span class="hljs-comment">//三角形顶点最大和就是它本身</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>]=dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+arr[i][<span class="hljs-number">0</span>];<br>            pre[i][<span class="hljs-number">0</span>]=pre[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-<span class="hljs-number">1</span>;<br>        &#125;                            <span class="hljs-comment">//只有通过arr[i-1][0]才能到达arr[i][0]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N;i++)&#123;<br>            dp[i][i]=dp[i-<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>]+arr[i][i];<br>            pre[i][i]=pre[i-<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>        &#125;                             <span class="hljs-comment">//只有通过arr[i-1][i-1]才能到达arr[i][i]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span> (dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]&gt;dp[i-<span class="hljs-number">1</span>][j])&#123;<br>                    pre[i][j]=pre[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>                    dp[i][j]=arr[i][j]+dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125;                     <br>                <span class="hljs-keyword">else</span>&#123;<br>                    pre[i][j]=pre[i-<span class="hljs-number">1</span>][j]-<span class="hljs-number">1</span>;<br>                    dp[i][j]=arr[i][j]+dp[i-<span class="hljs-number">1</span>][j];<br>                &#125;       <br> <br>            &#125;<br>        &#125;               <span class="hljs-comment">//arr[i][j]可以从arr[i-1][j-1]或arr[i-1][j]到达所以要比较找出最大值</span><br>        <span class="hljs-type">int</span>[] sum=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [N];   <span class="hljs-comment">//定义sum数组储存到达最底部符合条件的和初始为零</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>            sum[i]=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (pre[N-<span class="hljs-number">1</span>][i]&lt;=<span class="hljs-number">1</span>&amp;&amp;pre[N-<span class="hljs-number">1</span>][i]&gt;=-<span class="hljs-number">1</span>)&#123;<br>                sum[i]=dp[N-<span class="hljs-number">1</span>][i];<br>            &#125;                  <span class="hljs-comment">//pre二维数组记录路径只要为-1，0，1三个数就说明向左下和右下走的次数不超过1，记录数据最终进行比较</span><br> <br>        &#125;<br>        <span class="hljs-type">int</span> max=sum[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>            <span class="hljs-keyword">if</span>(max&lt;sum[i])&#123;<br>                max=sum[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                max=max;<br>            &#125;<br>        &#125;                  <br>        System.out.println(max);     <span class="hljs-comment">//通过比较选出最大路径并输出</span><br>        scan.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>将数字三角形转化到为二维数组中进行存储，由于最左侧一列和对角线都有固定的路径，再加以分析得到中间数字的路径从而获得三个状态转移方程（除去顶点）：</p><p>dp[i][0]&#x3D;dp[i-1][0]+arr[i][0];</p><p>dp[i][i]&#x3D;dp[i-1][i-1]+arr[i][i];</p><p>dp[i][j]&#x3D;max(dp[i-1][j-1],dp[i-1][j])+arr[i][j];</p><p>题目还对左下和右下走的次数有限制，因此我们用pre二维数组记录路径左下走-1右下走+1最终进行判断比较得出最大值并输出。</p><p><strong>CSDN</strong> <a href="https://blog.csdn.net/qq_63746090/article/details/129246539?spm=1001.2014.3001.5501">原文链接</a></p>]]></content>
    
    
    <categories>
      
      <category>日常练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/04/26/hello-world/"/>
    <url>/2023/04/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
